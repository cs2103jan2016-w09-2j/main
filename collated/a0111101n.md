# a0111101n
###### \src\tucklife\storage\Storage.java
``` java
package tucklife.storage;


import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;
import tucklife.storage.TaskList;

public class Storage {
	
	private static final Logger log = Logger.getLogger( Storage.class.getName() );
	
	private static final String RETURN_MESSAGE_FOR_ADD = "{%1$s} has been added to TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_EDIT = "{%1$s} has been edited in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_DELETE = "{%1$s} has been deleted from TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_QUEUE = "{%1$s} has been added to TuckLife's queue at position {%2$s}!";
	private static final String RETURN_MESSAGE_FOR_SETLIMIT = "Limit has been set to %1$s in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_SETLIMIT_WHEN_ABOVE_LIMIT = RETURN_MESSAGE_FOR_SETLIMIT
			+ " Be aware that there are some days with more tasks than your new limit!";
	private static final String RETURN_MESSAGE_FOR_SETLIMIT_OFF = "Limit has been turned off in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_COMPLETE = "{%1$s} has been moved to TuckLife's done list!";
	
	private static final String RETURN_MESSAGE_FOR_NONEXISTENT_ID = "No task with id:%1$s in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_OVERLOAD = "That day has been filled with %1$s tasks! It hit the limit! You should reschedule the task to another day. "
			+ "Alternatively, you can either change the overload limit or turn it off.";
	private static final String RETURN_MESSAGE_FOR_NOTHING_TO_UNDO = "There is no previous action to undo!";
	private static final String RETURN_MESSAGE_FOR_NOTHING_TO_REDO = "There is no previous action to redo!";
	
	private static final String STATUS_HEADER = "Tasks at a glance...";
	private static final String STATUS_OUTSTANDING = "Total outstanding tasks: %1$s";
	private static final String STATUS_TODAY = "Tasks due today: %1$s";
	private static final String STATUS_CURRENT = "Current task: {%1$s}";
	private static final String STATUS_CURRENT_NONE = "None";
	
	private static TaskList toDoList;
	private static TaskList doneList;
	
	private static TaskList queueList;
	
	private static ArrayList<ArrayList<TaskList>> undoSaveState = new ArrayList<ArrayList<TaskList>>();
	private static ArrayList<ArrayList<TaskList>> redoSaveState = new ArrayList<ArrayList<TaskList>>();

	private static PrefsStorage pf;
	
	private enum COMMAND_TYPE {
		ADD, DISPLAY, COMPLETE, DISPLAYDONE, DELETE, EDIT, INVALID, QUEUE, SETLIMIT, UNDO, REDO
	}
	
	public String parseCommand(ProtoTask pt) {
		COMMAND_TYPE ct = determineCommandType(pt.getCommand());
		String returnMessage = parseCommand(pt,ct);
		return returnMessage;
	}

	private static void storeUndoSaveState() {
		ArrayList<TaskList> saveState = getSaveState();
		
		if (undoSaveState.size() < 50) {
			undoSaveState.add(saveState);
		} else {
			undoSaveState.remove(0);
			undoSaveState.add(saveState);
		}
	}
	
	private static void storeRedoSaveState() {
		ArrayList<TaskList> saveState = getSaveState();
		
		if (redoSaveState.size() < 50) {
			redoSaveState.add(saveState);
		} else {
			redoSaveState.remove(0);
			redoSaveState.add(saveState);
		}
	}

	private static ArrayList<TaskList> getSaveState() {
		ArrayList<TaskList> saveState = new ArrayList<TaskList>();
		
		TaskList oldToDoList = duplicateTaskList(toDoList);
		TaskList oldQueueList = getQueueListFromToDoList(oldToDoList);
		
		saveState.add(oldToDoList);
		saveState.add(oldQueueList);
		
		TaskList oldDoneList = duplicateTaskList(doneList);
		
		saveState.add(oldDoneList);
		return saveState;
	}

	private static TaskList getQueueListFromToDoList(TaskList oldToDoList) {
		oldToDoList.sort(null, true);
		TaskList oldQueueList = new TaskList();
		Iterator<Task> taskListIter = oldToDoList.iterator();
		while(taskListIter.hasNext()){
			Task t = taskListIter.next();
			if(t.getQueueID()!=-1) {
				oldQueueList.add(t);
			}
		}
		return oldQueueList;
	}

	private static TaskList duplicateTaskList(TaskList originalList) {
		TaskList duplicateList = new TaskList();
		Iterator<Task> taskListIter = originalList.iterator();
		while(taskListIter.hasNext()){
			Task t = new Task(taskListIter.next());
			duplicateList.add(t);
		}
		return duplicateList;
	}
	
	private static String undo() throws nothingToUndoException{
		if (undoSaveState.size() == 0) {
			throw new nothingToUndoException();
		}
		storeRedoSaveState();
		ArrayList<TaskList> saveState = undoSaveState.remove(undoSaveState.size()-1);
		restoreSaveState(saveState);
		return "undone";
	}

	private static void restoreSaveState(ArrayList<TaskList> saveState) {
		toDoList = saveState.get(0);
		queueList = saveState.get(1);
		doneList = saveState.get(2);
	}
	
	private static String redo() throws nothingToRedoException{
		if (redoSaveState.size() == 0) {
			throw new nothingToRedoException();
		}
		storeUndoSaveState();
		ArrayList<TaskList> saveState = redoSaveState.remove(redoSaveState.size()-1);
		restoreSaveState(saveState);
		return "redone";
	}
	
	public DataBox save() {
		TaskList[] saveList = new TaskList[2];
		saveList[0] = toDoList;
		saveList[1] = doneList;
		DataBox db = new DataBox(saveList, new PrefsStorage());
		return db;
	}
	
	public void load(DataBox db) {
		TaskList[] loadList = db.getLists();
		toDoList = loadList[0];
		doneList = loadList[1];
		queueList = getQueueListFromToDoList(toDoList);
		pf = db.getPrefs();
	}
	
	private static COMMAND_TYPE determineCommandType(String commandTypeString) {
		if (commandTypeString.equalsIgnoreCase("add")) {
			return COMMAND_TYPE.ADD;
		} else if (commandTypeString.equalsIgnoreCase("complete")) {
			return COMMAND_TYPE.COMPLETE;
		} else if (commandTypeString.equalsIgnoreCase("display")) {
			return COMMAND_TYPE.DISPLAY;
		} else if (commandTypeString.equalsIgnoreCase("displaydone")) {
			return COMMAND_TYPE.DISPLAYDONE;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return COMMAND_TYPE.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("edit")) {
			return COMMAND_TYPE.EDIT;
		} else if (commandTypeString.equalsIgnoreCase("queue")) {
			return COMMAND_TYPE.QUEUE;
		} else if (commandTypeString.equalsIgnoreCase("setlimit")) {
			return COMMAND_TYPE.SETLIMIT;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return COMMAND_TYPE.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return COMMAND_TYPE.REDO;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}
	
	private static String parseCommand(ProtoTask pt, COMMAND_TYPE commandType) throws Error {
		switch (commandType) {
		case ADD :
			try {
				prepareForUndo();
				return add(pt);
			} catch (overloadException e) {
				return String.format(RETURN_MESSAGE_FOR_OVERLOAD, e.getLimit());
			} catch (invalidDateException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		case COMPLETE :
			prepareForUndo();
			return complete(pt.getId());
		case DISPLAY :
			return display(pt);
		case DISPLAYDONE :
			return displayDone();
		case DELETE :
			prepareForUndo();
			return delete(pt.getId());
		case EDIT :
			try {
				prepareForUndo();
				return edit(pt.getId(), pt);
			} catch (overloadException e) {
				return String.format(RETURN_MESSAGE_FOR_OVERLOAD, e.getLimit());
			} catch (invalidDateException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		case QUEUE :
			prepareForUndo();
			return queue(pt.getId(), pt.getPosition());
		case SETLIMIT :
			return setLimit(pt.getLimit());
		case UNDO :
			try {
				return undo();
			} catch (nothingToUndoException e) {
				return RETURN_MESSAGE_FOR_NOTHING_TO_UNDO;
			}
		case REDO :
			try {
				return redo();
			} catch (nothingToRedoException e) {
				return RETURN_MESSAGE_FOR_NOTHING_TO_REDO;
			}
		default:
			//throw an error if the command is not recognized
			throw new Error("Unrecognized command type");
		}
	}

	private static void prepareForUndo() {
		storeUndoSaveState();
		redoSaveState.clear();
	}
	
	private static String add(ProtoTask task) throws overloadException, invalidDateException{
		Task newTask = new Task(task);
		if (newTask.isFloating()) {
			toDoList.add(newTask);
			return String.format(RETURN_MESSAGE_FOR_ADD, newTask.displayAll());
		}
		toDoList.sort("$",true);
		if(isOverloaded(newTask)) {
			throw new overloadException(pf.getOverloadLimit());
		}
		
		toDoList.add(newTask);
		return String.format(RETURN_MESSAGE_FOR_ADD, newTask.displayAll());
	}

	private static boolean isOverloaded(Task newTask) {
		if(newTask.isFloating() || newTask.getStartDate() != null) { //dont count floating tasks and events
			return false;
		}
		
		int limit = pf.getOverloadLimit();
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy");
		String newTaskDateString = sdf.format(newTask.getEndDate().getTime());
		return checkIsOverloaded(limit, newTaskDateString);
	}

	private static boolean checkIsOverloaded(int limit, String newTaskDateString) {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy");
		boolean flag = true;
		boolean hitLimit = false;
		int count = 0;
		String oldDateString = null;
		Iterator<Task> taskListIter = toDoList.iterator();
		
		while(taskListIter.hasNext()) {
			Task t = taskListIter.next();
			
			if(t.isFloating() || t.getStartDate() != null) { //dont count floating tasks and events
				continue;
			} 
			
			String taskEndDateString = sdf.format(t.getEndDate().getTime());
			
			if(taskEndDateString.equals(oldDateString)) {
				count += 1;
			} else {
				oldDateString = taskEndDateString;
				count = 1;
			}
			if(flag) {
				if(taskEndDateString.equals(newTaskDateString)) {
					count +=1;
					flag = false;
				}
			}
			if(count == limit+1) {
				hitLimit = true;
				break;
			}
		}
		return hitLimit;
	}
	
	private static String edit(int taskID, ProtoTask toEditTask) throws overloadException, invalidDateException {
		Task newTask = new Task(toEditTask);
		if(isOverloaded(newTask)) {
			throw new overloadException(pf.getOverloadLimit());
		}
		toDoList.edit(taskID, toEditTask);
		String editedTaskDetails = toDoList.displayID(taskID);
		return String.format(RETURN_MESSAGE_FOR_EDIT, editedTaskDetails);
	}
	
	private static String complete(int taskID) {
		if(toDoList.contains(taskID)){
			Task completedTask = toDoList.delete(taskID);
			completedTask.setQueueID(-1);
			if(queueList.contains(taskID)) {
				queueList.delete(taskID);
				updateQueueIDs(0, 0);
			}
			doneList.add(completedTask);
			return String.format(RETURN_MESSAGE_FOR_COMPLETE, completedTask.displayAll());
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}
	
	private static String delete(int taskID) {
		if(toDoList.contains(taskID)){
			Task deletedTask = toDoList.delete(taskID);
			if(queueList.contains(taskID)) {
				queueList.delete(taskID);
				updateQueueIDs(0, 0);
			}
			return String.format(RETURN_MESSAGE_FOR_DELETE, deletedTask.displayAll());
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}
	
	private static String displayID(int taskID) {
		if(toDoList.contains(taskID)){
			return toDoList.displayID(taskID);
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}
	
	private static String display(ProtoTask pt) {
		if (pt.getSearchKey()!=null) {
			toDoList.sort(null, true);
			return toDoList.search(pt.getSearchKey());
		}
		
		if(pt.getId() != -1) {
			return displayID(pt.getId());
		} else {
			String sortBy = pt.getSortCrit();
			assert sortBy.equals("@") || sortBy.equals("!") || sortBy.equals("#") || sortBy.equals("$") || sortBy.equals("&") || sortBy.equals("+") || sortBy == null;
			boolean isAscending = pt.getIsAscending();
			toDoList.sort(sortBy,isAscending);
			if (sortBy == null) {
				return toDoList.displayDefault();
			} else {
				return toDoList.display();
			}
		}
	}
	
	private static String displayDone() {
		return doneList.display();
	}
	
	private static String queue(int taskID, int pos) {
		if(toDoList.contains(taskID)){
			boolean flag = false;
			Task qTask = toDoList.get(taskID);
			if(pos == -1 || pos>queueList.size()) {
				pos = queueList.size();
				flag = true;
			}
			if(queueList.contains(taskID)) {
				
				queueList.delete(taskID);
				queueList.add(pos-1,qTask);
				
			} else {
				if(flag) {
					queueList.add(pos,qTask);
				} else {
					queueList.add(pos-1,qTask);
				}
			}
			
			pos = updateQueueIDs(taskID, pos);
				
			return String.format(RETURN_MESSAGE_FOR_QUEUE, qTask.displayAll(), pos);
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}

	private static int updateQueueIDs(int taskID, int pos) {
		Iterator<Task> qIter = queueList.iterator();
		int count = 1;
		while(qIter.hasNext()) {
			Task t = qIter.next();
			t.setQueueID(count);
			if(t.getId() == taskID) {
				pos = t.getQueueID();
			}
			count++;
		}
		return pos;
	}
	
	private static String setLimit(int limit) {
		assert limit >= 0;
		pf.setOverloadLimit(limit);
		if(limit == 0) {
			pf.setOverloadLimit(-1);
			return RETURN_MESSAGE_FOR_SETLIMIT_OFF;
		} else if(checkIsOverloaded(limit, null)) {
			return String.format(RETURN_MESSAGE_FOR_SETLIMIT_WHEN_ABOVE_LIMIT, limit);
		} else {
			return String.format(RETURN_MESSAGE_FOR_SETLIMIT, limit);
		}
	}
	
	public String getStatus(){
		StringBuilder status = new StringBuilder();
		
		status.append(STATUS_HEADER);
		status.append("\n");
		status.append(String.format(STATUS_OUTSTANDING, Integer.toString(toDoList.size())));
		status.append("\n");
		status.append(String.format(STATUS_TODAY, Integer.toString(toDoList.tasksToday())));
		status.append("\n");
		if(queueList.size() != 0){
			status.append(String.format(STATUS_CURRENT, queueList.display().split("\n")[0]));
		} else{
			status.append(String.format(STATUS_CURRENT, STATUS_CURRENT_NONE));
		}
		
		return status.toString();
	}
	
	
	//for testing purposes only
	public static void clear(){
		Task.resetGlobalId();
		pf = new PrefsStorage();
		setLimit(0);
		toDoList = new TaskList();
		queueList = new TaskList();
		doneList = new TaskList();
		undoSaveState = new ArrayList<ArrayList<TaskList>>();
		redoSaveState = new ArrayList<ArrayList<TaskList>>();
	}
	
	public static TaskList getTD(){
		return toDoList;
	}
	
	public static TaskList getQ(){
		return queueList;
	}
}
```
###### \src\tucklife\storage\StorageTest.java
``` java
package tucklife.storage;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Hashtable;

import org.junit.Before;
import org.junit.Test;

import tucklife.parser.Parser;
import tucklife.parser.ProtoTask;

public class StorageTest {
	
	Parser p;
	Storage s;
	
	@Before
	public void setUp() throws Exception {
		p = new Parser();
		s = new Storage();
		Hashtable<String,String> ht = new Hashtable<String,String>();
		p.loadCommands(ht);
	}
	ArrayList<ArrayList<TaskList>> al = new ArrayList<ArrayList<TaskList>>();
	@Test
	public void testal() {
		assertEquals(al.size(), 0);
	}
	
	@Test
	public void testSortLocation() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @as4-mr3");
		ProtoTask pt2 = p.parse("add staff retreat @sentosa");
		ProtoTask pt3 = p.parse("add interview intern");
		
		ProtoTask pt4 = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		assertEquals("not sorted",s.parseCommand(pt4),"3. interview intern\n1. meeting | Location: as4-mr3\n2. staff retreat | Location: sentosa\n");
		
		ProtoTask pt5 = p.parse("display +@");
		assertEquals("sorted ascending",s.parseCommand(pt5),"1. meeting | Location: as4-mr3\n2. staff retreat | Location: sentosa\n3. interview intern\n");
		ProtoTask pt6 = p.parse("display -@");
		assertEquals("sorted descending",s.parseCommand(pt6),"3. interview intern\n2. staff retreat | Location: sentosa\n1. meeting | Location: as4-mr3\n");
	}
	
	@Test
	public void testOverload() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7 $16/05 +1400");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $16/05 +1300");
		
		ProtoTask pt4 = p.parse("setlimit 4");
		
		ProtoTask pt5 = p.parse("add 4th task $16/05 +2359");
		ProtoTask pt6 = p.parse("add overload $16/05 +2300");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);

		assertEquals("able to add",s.parseCommand(pt5),"{4. 4th task | By: Mon, 16 May 2016 23:59} has been added to TuckLife's to-do list!");
		assertEquals("unable to add, hit limit",s.parseCommand(pt6),"That day has been filled with 4 tasks! It hit the limit! You should reschedule the task to another day. Alternatively, you can either change the overload limit or turn it off.");
	}
	
	@Test
	public void testOverload2() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7 $16/05 +1400");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $16/05 +1300");
		
		ProtoTask pt4 = p.parse("setlimit 4");
		
		ProtoTask pt5 = p.parse("add 4th task $16/05 +2359");
		ProtoTask pt6 = p.parse("add overload $17/05 +2300");
		ProtoTask pt7 = p.parse("edit 5 $16/05");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);

		assertEquals("able to add",s.parseCommand(pt5),"{4. 4th task | By: Mon, 16 May 2016 23:59} has been added to TuckLife's to-do list!");
		assertEquals("able to add",s.parseCommand(pt6),"{5. overload | By: Tue, 17 May 2016 23:00} has been added to TuckLife's to-do list!");
		assertEquals("unable to add, hit limit",s.parseCommand(pt7),"That day has been filled with 4 tasks! It hit the limit! You should reschedule the task to another day. Alternatively, you can either change the overload limit or turn it off.");
	}
	
	@Test
	public void testOverload3() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7 $16/05 +1400");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $16/05 +1300");
		
		ProtoTask pt4 = p.parse("setlimit 4");
		
		ProtoTask pt5 = p.parse("add 4th task $16/05 +2359");
		ProtoTask pt6 = p.parse("add redundant $17/05 +2300");
		ProtoTask pt7 = p.parse("add overload $16/05 +2300");
		
		ProtoTask pt8 = p.parse("add safety awareness week $09/05 to 16/05 #gg");
		ProtoTask pt9 = p.parse("add holiday $10/05 to 16/05 &to siam stupid stuff");
		ProtoTask pt10 = p.parse("add meeting $16/05 +2pm to 3pm");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		
		s.parseCommand(pt9);

		assertEquals("able to add",s.parseCommand(pt5),"{5. 4th task | By: Mon, 16 May 2016 23:59} has been added to TuckLife's to-do list!");
		assertEquals("able to add",s.parseCommand(pt6),"{6. redundant | By: Tue, 17 May 2016 23:00} has been added to TuckLife's to-do list!");
		assertEquals("unable to add, hit limit",s.parseCommand(pt7),"That day has been filled with 4 tasks! It hit the limit! You should reschedule the task to another day. Alternatively, you can either change the overload limit or turn it off.");
		assertEquals("able to add, hit limit",s.parseCommand(pt8),"{8. safety awareness week | From: Mon, 9 May 2016 00:00 To: Mon, 16 May 2016 23:59 | Category: gg} has been added to TuckLife's to-do list!");
		assertEquals("unable to add, hit limit",s.parseCommand(pt10),"{9. meeting | From: Mon, 16 May 2016 14:00 To: Mon, 16 May 2016 15:00} has been added to TuckLife's to-do list!");
		
	}
	
	@Test
	public void testSearch() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500 &meet at 4am");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16 &buy teammeet beer");
		ProtoTask pt7 = p.parse("add email boss $15/05 #siammeeting");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask search = p.parse("display meeting");
		s.parseCommand(search);
		assertEquals("search correctly", "Exact Match\n5. client meeting | By: Mon, 9 May 2016 23:59\n1. meeting | Location: meeting room 7\n\nPartial Match\n7. email boss | By: Sun, 15 May 2016 23:59 | Category: siammeeting\n",s.parseCommand(search));
	}
	
	@Test
	public void testSearch2() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500 &meet at 4am");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16 &buy teammeet beer");
		ProtoTask pt7 = p.parse("add email boss $15/05 #siammeeting");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask search = p.parse("display meet");
		s.parseCommand(search);
		assertEquals("search correctly", "Exact Match\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens | Additional: meet at 4am\n\nPartial Match\n6. payday | By: Thu, 5 May 2016 23:59 | Additional: buy teammeet beer\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59 | Category: siammeeting\n1. meeting | Location: meeting room 7\n", s.parseCommand(search));
	}
	
	@Test
	public void testSearch3() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500 &Meet at 4am");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client Meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16 &buy teammeet beer");
		ProtoTask pt7 = p.parse("add email boss $15/05 #siammeeting");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask search = p.parse("display meet");
		s.parseCommand(search);
		assertEquals("search correctly", "Exact Match\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens | Additional: Meet at 4am\n\nPartial Match\n6. payday | By: Thu, 5 May 2016 23:59 | Additional: buy teammeet beer\n5. client Meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59 | Category: siammeeting\n1. meeting | Location: meeting room 7\n", s.parseCommand(search));
	}
	
	@Test
	public void testUndo() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		
		ProtoTask ptDisplay = p.parse("display ++");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		
		assertEquals("check display",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		ProtoTask pt5 = p.parse("undo");	
		s.parseCommand(pt5);
		assertEquals("check display change",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n1. meeting | Location: meeting room 7\n");
	}
	
	@Test
	public void testUndo2() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask undo = p.parse("undo");
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to handle non-consecutive undos", 8, td.size());
	}
	
	@Test
	public void testMultipleUndo() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask undo = p.parse("undo");
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 5, td.size());
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 4, td.size());
	}
	
	@Test
	public void testUndoForQueue() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		
		assertEquals("check display",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		ProtoTask pt4 = p.parse("queue 1");
		s.parseCommand(pt4);
		assertEquals("task is queued",s.parseCommand(ptDisplay),"Queue:\n1. meeting | Location: meeting room 7\n\nOther Tasks:\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n");
		ProtoTask pt5 = p.parse("undo");	
		s.parseCommand(pt5);
		assertEquals("task is unqueued",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
	}
	
	@Test
	public void testRedo() {
		Storage.clear();
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		
		ProtoTask ptDisplay = p.parse("display ++");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);

		assertEquals("check display",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask ptDO = p.parse("undo");	
		s.parseCommand(ptDO);
		assertEquals("check display change",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n1. meeting | Location: meeting room 7\n");
		
		ptDO = p.parse("redo");
		s.parseCommand(ptDO);
		assertEquals("check display",s.parseCommand(ptDisplay),"2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
	}
	
	@Test
	public void testMultipleRedo() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask undo = p.parse("undo");
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 5, td.size());
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 4, td.size());
		ProtoTask redo = p.parse("redo");
		s.parseCommand(redo);
		td = Storage.getTD();
		assertEquals("able to undo once", 5, td.size());
		s.parseCommand(redo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 6, td.size());
		s.parseCommand(redo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 7, td.size());
	}
	
	@Test
	public void testRedo2() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("added correctly", 7, td.size());
		
		ProtoTask undo = p.parse("undo");
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 5, td.size());
		s.parseCommand(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 4, td.size());
		s.parseCommand(pt5);
		ProtoTask redo = p.parse("redo");
		assertEquals("previous command not undo", s.parseCommand(redo), "There is no previous action to redo!");
	}
	
	@Test
	public void testQueue1() {
		s.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		t = td.get(5);
		assertEquals("task is added to back of queue", 3, t.getQueueID());
	}
	
	@Test
	public void testQueue11() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		ProtoTask pt13 = p.parse("queue 1 100");
		s.parseCommand(pt8);
		t = td.get(4);
		assertEquals("queue id is updated", 1, t.getQueueID());
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		assertEquals("queue id is updated", 2, t.getQueueID());
	}
	
	@Test
	public void testQueue2() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		t = td.get(5);
		assertEquals("task is added to back of queue", 3, t.getQueueID());
		ProtoTask pt11 = p.parse("queue 7 1");
		s.parseCommand(pt11);
		t = td.get(7);
		assertEquals("task is added to head of queue", 1, t.getQueueID());
	}
	
	@Test
	public void testQueue3() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		t = td.get(2);
		assertEquals("task is added to middle of queue", 4, t.getQueueID());
	}
	
	@Test
	public void testQueue4() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		ProtoTask pt13 = p.parse("queue 1 100");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		s.parseCommand(pt13);
		t = td.get(1);
		assertEquals("task is added to end of queue when pos > max queue", 6, t.getQueueID());
	}
	
	@Test
	public void testQueue5() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		ProtoTask pt13 = p.parse("queue 1 100");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		s.parseCommand(pt13);
		ProtoTask pt14 = p.parse("delete 2");
		s.parseCommand(pt14);
		t = td.get(5);
		assertEquals("queue id is update after deletion", 4, t.getQueueID());
	}
	
	@Test
	public void testQueue6() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		ProtoTask pt13 = p.parse("queue 1 100");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		s.parseCommand(pt13);
		ProtoTask pt14 = p.parse("complete 2");
		s.parseCommand(pt14);
		t = td.get(5);
		assertEquals("queue id is updated after completion", 4, t.getQueueID());
	}
	
	@Test
	public void testQueue7() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		ProtoTask pt13 = p.parse("queue 1 100");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		s.parseCommand(pt13);
		t = td.get(2);
		ProtoTask pt14 = p.parse("complete 2");
		s.parseCommand(pt14);
		assertEquals("queue id of completed is updated to default", -1, t.getQueueID());
	}
	
	@Test
	public void testQueueDisplay() {
		Storage.clear();
		
		TaskList td = Storage.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 4");
		ProtoTask pt13 = p.parse("queue 1 100");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		s.parseCommand(pt13);
		
		assertEquals("check normal display without queue","Queue:\n7. email boss | By: Sun, 15 May 2016 23:59\n4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n5. client meeting | By: Mon, 9 May 2016 23:59\n1. meeting | Location: meeting room 7\n\nOther Tasks:\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n",s.parseCommand(ptDisplay));
	}
	
	
	@Test
	public void testQueueWithUndo() {
		s.clear();
		
		TaskList td = s.getTD();
		Task t;
		
		ProtoTask pt1 = p.parse("add meeting @meeting room 7");
		ProtoTask pt2 = p.parse("add staff retreat @botanic gardens $16/05 +0500");
		ProtoTask pt3 = p.parse("add interview intern @mr5 $13/12/16");
		ProtoTask pt4 = p.parse("add financial report $01/05/16");
		ProtoTask pt5 = p.parse("add client meeting $09/05/16");
		ProtoTask pt6 = p.parse("add payday $05/05/16");
		ProtoTask pt7 = p.parse("add email boss $15/05");
		
		ProtoTask ptDisplay = p.parse("display");
		
		s.parseCommand(pt1);
		s.parseCommand(pt2);
		s.parseCommand(pt3);
		s.parseCommand(pt4);
		s.parseCommand(pt5);
		s.parseCommand(pt6);
		s.parseCommand(pt7);
		
		assertEquals("check normal display without queue",s.parseCommand(ptDisplay),"4. financial report | By: Sun, 1 May 2016 23:59\n6. payday | By: Thu, 5 May 2016 23:59\n5. client meeting | By: Mon, 9 May 2016 23:59\n7. email boss | By: Sun, 15 May 2016 23:59\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens\n3. interview intern | By: Tue, 13 Dec 2016 23:59 | Location: mr5\n1. meeting | Location: meeting room 7\n");
		
		ProtoTask pt8 = p.parse("queue 4");
		ProtoTask pt9 = p.parse("queue 6");
		ProtoTask pt10 = p.parse("queue 5");
		ProtoTask pt11 = p.parse("queue 7 1");
		ProtoTask pt12 = p.parse("queue 2 2");
		ProtoTask ptUndo = p.parse("undo");
		s.parseCommand(pt8);
		s.parseCommand(pt9);
		s.parseCommand(pt10);
		s.parseCommand(pt11);
		s.parseCommand(pt12);
		t = td.get(4);
		assertEquals("correct id", 3, t.getQueueID());
		s.parseCommand(ptUndo);
		td = s.getTD();
		t = td.get(6);
		assertEquals("correct id", 3, t.getQueueID());
	}

	
}
```
###### \src\tucklife\storage\Task.java
``` java
package tucklife.storage;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;

public class Task {
	
	private static final Logger log = Logger.getLogger( Storage.class.getName() );
	
	private String location;
	private int priority;
	private String category;
	private String additional;
	private String name;	
	
	private Calendar startDate; //if null, means that it is a task not event
	private Calendar endDate; //either deadline or end time for event. if null, means it is a floating task
	
	private boolean floating;
	
	private static int globalID = 1;

	private int id;
	
	private int queueID;
	
	private static final String HEADER_LOCATION = "Location: ";
	private static final String HEADER_CATEGORY = "Category: ";
	private static final String HEADER_PRIORITY = "Priority: ";
	private static final String HEADER_DEADLINE = "By: ";
	private static final String HEADER_ADDITIONAL = "Additional: ";
	private static final String HEADER_EVENT_START = "From: ";
	private static final String HEADER_EVENT_END = " To: ";
	
	private static final String PRIORITY_HIGH = "High";
	private static final String PRIORITY_MEDIUM = "Med";
	private static final String PRIORITY_LOW = "Low";
	
	public static void resetGlobalId() {
		globalID = 1;
	}
	
	public int getId(){
		return id;
	}
	
	public String getLocation() {
		return location;
	}

	public int getPriority() {
		return priority;
	}

	public String getCategory() {
		return category;
	}

	public String getAdditional() {
		return additional;
	}

	public String getName() {
		return name;
	}

	public Calendar getStartDate() {
		return startDate;
	}

	public Calendar getEndDate() {
		return endDate;
	}

	public boolean isFloating() {
		return floating;
	}

	public static int getGlobalID() {
		return globalID;
	}
	
	public int getQueueID(){
		return queueID;
	}
	
	public void setQueueID(int id){
		this.queueID = id;
	}
	
	public Task(ProtoTask task) throws invalidDateException{
		//create the Task
		this.location = task.getLocation();
		this.priority = task.getPriority();
		this.category = task.getCategory();
		this.additional = task.getAdditional();
		this.name = task.getTaskDesc();
		this.startDate = task.getStartDate();
		this.endDate = task.getEndDate();
		checkValidDates(startDate, endDate);
		this.floating = startDate == null && endDate == null; //task.isFloating();
		this.id = globalID;
		this.queueID = task.getPosition();
		globalID++;
		log.log( Level.FINE, "Task has been created via ProtoTask");
	}
	
	/* unsure if needed*/
	public Task(Task task){
		//create the Task
		this.location = task.getLocation();
		this.priority = task.getPriority();
		this.category = task.getCategory();
		this.additional = task.getAdditional();
		this.name = task.getName();
		this.startDate = task.getStartDate();
		this.endDate = task.getEndDate();
		this.floating = startDate == null && endDate == null; //task.isFloating();
		this.id = task.getId();	
		this.queueID = task.getQueueID();
	}//*/
	
	protected Task edit(ProtoTask task) throws invalidDateException{
		//edit task
		this.location = task.getLocation() == null ? this.location : task.getLocation();
		this.priority = task.getPriority() == -1 ? this.priority : task.getPriority();
		this.category = task.getCategory() == null ? this.category : task.getCategory();
		this.additional = task.getAdditional() == null ? this.additional : task.getAdditional();
		this.name = task.getTaskDesc() == null ? this.name : task.getTaskDesc();
		
		if(task.getStartTime() == null && task.getStartDate()!=null) {
			this.startDate = combineDateTime(task.getStartDate(),this.startDate); //merge date and time
		} else {
			if(task.getStartTime()!=null && task.getStartDate()!=null) {
				this.startDate = task.getStartDate();
			}
			if(task.getStartTime() == null && task.getStartDate() == null) {
				this.startDate = null;
			}
		}
		
		if(task.getEndTime() == null && task.getEndDate()!=null) {
			this.endDate = combineDateTime(task.getEndDate(),this.endDate); //merge date and time
		} else {
			if(task.getEndTime()!=null && task.getEndDate()!=null) {
				this.endDate = task.getEndDate();
			}
		}
		
		//this.startDate = task.getStartDate() == null ? this.startDate : task.getStartDate();
		//this.endDate = task.getEndDate() == null ? this.endDate : task.getEndDate();
		
		if(task.getStartDate() == null && task.getEndDate() == null) { //only do such changes if there is a time but no date
			
			if(task.getStartTime() == null && task.getEndTime()!=null) { //current task must be a deadline else it does not make sense
				if(this.startDate != null) {
					throw new invalidDateException();
				} else {
					if(this.endDate == null) { //current task is a floating task
						this.endDate = task.getEndTime(); //take deadline to be nearest time, similiar to the way add handles a single time
					} else {
						this.endDate = combineDateTime(this.endDate, task.getEndTime()); //change the time of the deadline
					}
				} 
			}
			
			if(task.getStartTime()!=null && task.getEndTime()!=null) { //new edited task becomes an event
				if(isFloating()) { //cant created an event from a floating task since you dont know the dates
					throw new invalidDateException();
				}
				
				if(this.startDate != null && this.startDate != this.endDate) {
					this.startDate = combineDateTime(this.startDate,task.getStartTime());
					this.endDate = combineDateTime(this.endDate,task.getEndTime());
				} else {
					if(onSameDay(task.getStartTime(),task.getEndTime())) {
						this.startDate = combineDateTime(this.endDate,task.getStartTime());
						this.endDate = combineDateTime(this.endDate,task.getEndTime());
					} else {
						this.startDate = combineDateTime(this.endDate,task.getStartTime());
						this.endDate = combineDateTime(tomorrow(this.endDate),task.getEndTime());
					}
				}
			}
		}
		
		checkValidDates(startDate, endDate);
		
		this.floating = startDate == null && endDate == null; //task.isFloating();
		this.id = task.getId() == -1 ? this.id : task.getId();
		log.log( Level.FINE, "Task has been edited via ProtoTask");
		return this;
	}
	
	private Calendar tomorrow(Calendar endDate) {
		endDate.add(Calendar.DATE, 1);
		return endDate;
	}

	private boolean onSameDay(Calendar startTime, Calendar endTime) {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy");
		return sdf.format(startTime.getTime()).equals(sdf.format(endTime.getTime()));
	}

	protected String display(){
		StringBuilder displayString = new StringBuilder();
		
		// display order:
		// id. name | date | location | priority
		
		displayString.append(idField());
		displayString.append(" ");
		displayString.append(name);
		
		String[] fields = new String[4];
		
		fields[0] = dateField();
		fields[1] = locationField();
		fields[2] = priorityField();
		
		for(int i = 0; i < 3; i++){
			if(fields[i] != null){
				displayString.append(" | ");
				displayString.append(fields[i]);
			}
		}
		
		return displayString.toString();
	}
	
	protected boolean containsExact(String searchKey) {
		String[] fields = new String[6];
		
		fields[0] = dateField();
		fields[1] = locationField();
		fields[2] = priorityField();
		fields[3] = categoryField();
		fields[4] = additionalField();
		fields[5] = getName();
		
		String searchItem = " " + searchKey + " ";
		
		for(int i = 0; i < 6; i++){
			if(fields[i] != null){
				String searchFrom = "  " + fields[i] + " ";
				if (searchFrom.toLowerCase().contains(searchItem.toLowerCase())) {
					return true;
				}
			}
		}
		return false;
	}
	
	protected boolean containsPartial(String searchKey) {
		if(this.containsExact(searchKey)) {
			return false;
		}
		String[] fields = new String[6];
		
		fields[0] = dateField();
		fields[1] = locationField();
		fields[2] = priorityField();
		fields[3] = categoryField();
		fields[4] = additionalField();
		fields[5] = getName();
		
		for(int i = 0; i < 6; i++){
			if(fields[i] != null){
				if (fields[i].toLowerCase().contains(searchKey.toLowerCase())) {
					return true;
				}
			}
		}
		return false;
	}
	
	private String idField(){
		return Integer.toString(id) + ".";
	}
	
	private String dateField(){
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy HH:mm");
		if(endDate == null){
			return null;
			
		} else if (endDate != null && startDate == null) {
			return HEADER_DEADLINE + sdf.format(endDate.getTime());
			
		} else if (endDate != null && startDate != null) {
			return HEADER_EVENT_START + sdf.format(startDate.getTime()) + HEADER_EVENT_END + sdf.format(endDate.getTime());
		}
		
		// shouldn't happen if task is correct
		return null;
	}
	
	private String locationField(){
		if (location == null) {
			return null;
		} else{
			return HEADER_LOCATION + location;
		}
	}
	
	private String priorityField(){
		if(priority == -1){
			return null;
		} else{
			switch(priority){
			case 1:
				return HEADER_PRIORITY + PRIORITY_HIGH;
			case 2:
				return HEADER_PRIORITY + PRIORITY_MEDIUM;
			case 3:
				return HEADER_PRIORITY + PRIORITY_LOW;
			
			// shouldn't happen if task is correct
			default:
				return null;
			}
		}
	}
	
	private String categoryField(){
		if (category == null) {
			return null;
		} else{
			return HEADER_CATEGORY + category;
		}
	}
	
	private String additionalField(){
		if(additional == null){
			return null;
		} else{
			return HEADER_ADDITIONAL + additional;
		}
	}
	
	protected String displayAll(){
		String displayString = display();
		String[] otherStuff = new String[2];
		
		otherStuff[0] = categoryField();
		otherStuff[1] = additionalField();
		
		for(int i = 0; i < 2; i++){
			if(otherStuff[i] != null){
				displayString += " | " + otherStuff[i];
			}
		}
		
		return displayString;
	}
	
	private Calendar combineDateTime(Calendar date, Calendar time) {
		if(date == null) {
			return null;
		}
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.YEAR, date.get(Calendar.YEAR));
		c.set(Calendar.MONTH, date.get(Calendar.MONTH));
		c.set(Calendar.DATE, date.get(Calendar.DATE));
		if (time == null) {
			c.set(Calendar.HOUR_OF_DAY, date.get(Calendar.HOUR_OF_DAY));
			c.set(Calendar.MINUTE, date.get(Calendar.MINUTE));
		} else {
			c.set(Calendar.HOUR_OF_DAY, time.get(Calendar.HOUR_OF_DAY));
			c.set(Calendar.MINUTE, time.get(Calendar.MINUTE));
		}
		
		return c;
	}
	
	private void checkValidDates(Calendar start, Calendar end) throws invalidDateException{
		if(end == null) {
			return;
		}
		if (end.before(start) && start!= null) {
			throw new invalidDateException();
		}
	}
	
}
```
###### \src\tucklife\storage\TaskList.java
``` java
package tucklife.storage;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;


public class TaskList {
	
	private static final Logger log = Logger.getLogger( Storage.class.getName() );

	private ArrayList<Task> taskList;
	
	// intended for use when table is aligned
	private static final String HEADER_ID = "ID";
	private static final String HEADER_NAME = "Name";
	private static final String HEADER_LOCATION = "Location";
	private static final String HEADER_CATEGORY = "Category";
	private static final String HEADER_PRIORITY = "Priority";
	private static final String HEADER_DEADLINE = "By";
	private static final String HEADER_ADDITIONAL = "Additional";
	private static final String HEADER_EVENT_START = "From";
	private static final String HEADER_EVENT_END = " To";
	
	public TaskList() {		
		taskList = new ArrayList<Task>();
	}
	
	protected boolean contains(int taskID){
		boolean containsID = false;
		for (Task task:taskList) {
			if (hasFoundID(taskID, task)) {
				containsID = true;
			}
		}
		return containsID;
	}
	
	protected String displayID(int taskID) {
		String displayString = "";
		for (Task task:taskList) {
			if (hasFoundID(taskID, task)) {
				displayString = task.displayAll();
			}
		}
		return displayString;
	}
	
	protected String display() {
		StringBuilder sb = new StringBuilder();
		
		for (Task task:taskList) {
			sb.append(task.display());
			sb.append("\n");
		}
		return sb.toString();
	}
	
	protected String displayDefault() {
		StringBuilder sb = new StringBuilder();
		boolean qFlag = false;
		boolean othersFlag = false;
		for (Task task:taskList) {
			if (task.getQueueID() == -1 && !qFlag) {
				return display();
			}
			if(task.getQueueID() != -1 && !qFlag) {
				sb.append("Queue:\n");
				qFlag = true;
			}
			if(task.getQueueID() == -1 && !othersFlag) {
				sb.append("\nOther Tasks:\n");
				othersFlag = true;
			}
			sb.append(task.display());
			sb.append("\n");
		}
		return sb.toString();
	}
	
	protected String search(String searchKey) {
		StringBuilder sb = new StringBuilder();
		
		sb.append("Exact Match\n");
		for (Task task:taskList) {
			if(task.containsExact(searchKey)) {
				sb.append(task.displayAll());
				sb.append("\n");
			}
		}
		
		sb.append("\nPartial Match\n");
		for (Task task:taskList) {
			if(task.containsPartial(searchKey)) {
				sb.append(task.displayAll());
				sb.append("\n");
			}
		}
		return sb.toString();
	}
	
	protected void add(ProtoTask task) throws invalidDateException {
		Task newTask = new Task(task);
		taskList.add(newTask);
		log.log( Level.FINE, "{0} added to tasklist via ProtoTask", newTask.getName());
	}
	
	protected void add(Task task) {
		taskList.add(task);
		log.log( Level.FINE, "{0} added to tasklist via Task", task.getName());
	}
	
	protected void add(int index, Task task) {
		taskList.add(index, task);
		log.log( Level.FINE, "{0} added to tasklist via index:{1} and Task", new Object[]{task.getName(), index});
	}
	
	protected int size() {
		return taskList.size();
	}
	
	protected Task delete(int taskID) {
		Task removed = null; 
		for (Task task:taskList) {
			if (hasFoundID(taskID, task)) {
				removed = task;
			}
		}
		if (taskList.remove(removed)) {
			log.log( Level.FINE, "{0} has been removed", removed.getName());
		}
		return removed;
	}
	
	protected Task remove(int index) {
		Task t = taskList.remove(index);
		log.log( Level.FINE, "{0} has been removed", t.getName());
		return t;
	}
	
	protected void edit(int taskID, ProtoTask toEditTask) throws invalidDateException {
		for (Task task:taskList) {
			if (hasFoundID(taskID, task)) {
				int taskIndex = taskList.indexOf(task);
				Task newTask = task.edit(toEditTask);
				taskList.set(taskIndex, newTask);
				log.log( Level.FINE, "{0} has been edited", newTask.getName());
			}
		}
	}
	
	protected Task get(int taskID) {
		Task getTask = null; 
		for (Task task:taskList) {
			if (hasFoundID(taskID, task)) {
				getTask = task;
			}
		}
		return getTask;
	}

	private boolean hasFoundID(int taskID, Task task) {
		return task.getId() == taskID;
	}
	
	public Iterator<Task> iterator() {
		return taskList.iterator();
	}
	
	protected void sort(String sortBy , boolean isAscending) {
		if (sortBy != null) {
			if (sortBy.equals("@")) {
				Collections.sort(taskList,new taskComparators().new ComparatorLocation());
				log.log( Level.FINE, "tasklist has been sorted by location");
			}
			
			if (sortBy.equals("!")) {
				Collections.sort(taskList,new taskComparators().new ComparatorPriority());
				log.log( Level.FINE, "tasklist has been sorted by priority");
			}
			
			if (sortBy.equals("#")) {
				Collections.sort(taskList,new taskComparators().new ComparatorCategory());
				log.log( Level.FINE, "tasklist has been sorted by category");
			}
			
			if (sortBy.equals("$")) {
				Collections.sort(taskList,new taskComparators().new ComparatorTime());
				log.log( Level.FINE, "tasklist has been sorted by time");
			}
			
			if (sortBy.equals("+")) { //is there actually a point doing this?? Im setting it to time for now
				Collections.sort(taskList,new taskComparators().new ComparatorTime());
				log.log( Level.FINE, "tasklist has been sorted by time");
			}
			
			if (sortBy.equals("&")) {
				Collections.sort(taskList,new taskComparators().new ComparatorAdditional());
				log.log( Level.FINE, "tasklist has been sorted by additional information");
			}
			
			if (!isAscending) {
				Collections.reverse(taskList);
				log.log( Level.FINE, "tasklist has been sorted in reverse order");
			}
		}
		else {
			Collections.sort(taskList,new taskComparators().new ComparatorDefault());
			log.log( Level.FINE, "tasklist has been sorted by queue number, then by time");
			//Collections.reverse(taskList);
		}
	}
	
	protected int tasksToday(){
		Calendar c = Calendar.getInstance();
		int count = 0;
		
		for(Task t: taskList){
			
			if(t.isFloating() || t.getStartDate() != null) {
				continue;
			} 
			
			Calendar deadline = t.getEndDate();
			
			if(c.get(Calendar.YEAR) == deadline.get(Calendar.YEAR) &&
					c.get(Calendar.DAY_OF_YEAR)  == deadline.get(Calendar.DAY_OF_YEAR)){
				count += 1;
			}
		}
			
		return count;
	}
	
}
```
###### \src\tucklife\storage\TaskTest.java
``` java
package tucklife.storage;

import static org.junit.Assert.*;

import java.util.Hashtable;

import org.junit.Before;
import org.junit.Test;

import tucklife.parser.Parser;
import tucklife.parser.ProtoTask;

public class TaskTest {


	private Task t;
	private int id;
	private Parser p;
	private ProtoTask pt;

	@Before
	public void setUp() throws Exception {
		p = new Parser();
		Hashtable<String,String> ht = new Hashtable<String,String>();
		p.loadCommands(ht);
	}
	
	@Test
	public void testTask() throws invalidDateException {
		pt = p.parse("add meeting");
		Task t = new Task(pt);
		assertEquals("fail to create task", t.getName(), "meeting");
		assertEquals("unable to get correct location", t.getLocation(), null);
		pt = p.parse("add meeting with boss @mr3");
		t = new Task(pt);
		assertEquals("unable to get correct location", t.getLocation(), "mr3");
	}
	
	@Test
	public void testDisplay() throws invalidDateException {
		pt = p.parse("add meeting");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting",id);
		assertEquals("fail to display", t.display(), taskDisplay);
		pt = p.parse("add meeting with boss @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		taskDisplay = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 12:00 | Location: mr3",id);
		assertEquals("fail to display properly", t.display(), taskDisplay);
		taskDisplay = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 12:00 | Location: mr3 | Category: important | Additional: bring all documents",id);
		assertEquals("fail to display all properly", taskDisplay, t.displayAll());
	}
	
	@Test
	public void testEdit() throws invalidDateException {
		pt = p.parse("add meeting with boss @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 12:00 | Location: mr3",id);
		pt = p.parse(String.format("edit %1$s @mr4 +1300 $17/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting with boss | By: Tue, 17 May 2016 13:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
		taskDisplay = String.format("%1$s. meeting with boss | By: Tue, 17 May 2016 13:00 | Location: mr4 | Category: important | Additional: bring all documents",id);
		assertEquals("fail to display all properly", t.displayAll(), taskDisplay);
	}
	
	@Test
	public void testEdit2() throws invalidDateException {
		pt = p.parse("add meeting with boss @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 12:00 | Location: mr3",id);
		pt = p.parse(String.format("edit %1$s @mr4 +1300",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 13:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
		taskDisplay = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 13:00 | Location: mr4 | Category: important | Additional: bring all documents",id);
		assertEquals("fail to display all properly", t.displayAll(), taskDisplay);
	}
	
	@Test
	public void testEdit3() throws invalidDateException {
		pt = p.parse("add meeting with boss @mr3 +1200 to 1300 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +1100 to 1200",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting with boss | From: Mon, 16 May 2016 11:00 To: Mon, 16 May 2016 12:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit4() throws invalidDateException {
		pt = p.parse("add meeting with boss @mr3 +1200 to 1300 $16/05 to 17/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +0900 to 1000",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting with boss | From: Mon, 16 May 2016 09:00 To: Tue, 17 May 2016 10:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit5() throws invalidDateException {
		pt = p.parse("add meeting with boss @mr3 +1200 to 1300 $16/05 to 17/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +0900 $16/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting with boss | By: Mon, 16 May 2016 09:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit6() throws invalidDateException {
		pt = p.parse("add company trip with boss @mr3 +0900 to 1000 $19/05 to 20/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05 to 17/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip with boss | From: Mon, 16 May 2016 09:00 To: Tue, 17 May 2016 10:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit7() throws invalidDateException {
		pt = p.parse("add company trip with boss @mr3 +1700 $19/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip with boss | By: Mon, 16 May 2016 17:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit8() throws invalidDateException {
		pt = p.parse("add company trip with boss $16/06 +1500");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip with boss | By: Mon, 16 May 2016 15:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit9() throws invalidDateException {
		pt = p.parse("add company trip with boss");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05 +1500",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip with boss | By: Mon, 16 May 2016 15:00 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit10() throws invalidDateException {
		pt = p.parse("add company trip with boss");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip with boss | By: Mon, 16 May 2016 23:59 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testEdit11() throws invalidDateException {
		pt = p.parse("add company trip with boss");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05 to 17/05",id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip with boss | From: Mon, 16 May 2016 00:00 To: Tue, 17 May 2016 23:59 | Location: mr4",id);
		assertEquals("fail to display properly", t.display(), taskDisplayEdit);
	}
	
	@Test
	public void testSearch1() throws invalidDateException {
		ProtoTask pt1 = p.parse("add go to gap @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt1);
		t.containsExact("gAp");
	}
	
	@Test
	public void testSearch2() throws invalidDateException {
		ProtoTask pt2 = p.parse("add travelling @Singapore");
		t = new Task(pt2);
		t.containsPartial("gap");
	}
}

```
