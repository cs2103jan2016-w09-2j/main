# A0127835Y
###### \src\tucklife\parser\DateParser.java
``` java
package tucklife.parser;

import java.util.Calendar;
import java.util.Date;
import java.text.ParseException;
import java.text.SimpleDateFormat;

/*
 * Supported date formats:
 * - Text dates:
 *   - Both short month names (jan, feb) and full month names (january, february)
 *   - ddmmm or ddmmmyy or ddmmmyyyy (15jan)
 *   - dd mmm or dd mmm yy or dd mmm yyyy (15 jan)
 *   - dd-mmm or dd-mmm-yy or dd-mmm-yyyy (15-jan)
 *   
 * - Number dates:
 *   - dd/mm or dd/mm/yy or dd/mm/yyyy (15/1)
 *   - dd.mm or dd.mm.yy or dd.mm.yyyy (15.1)
 *   - dd-mm or dd-mm-yy or dd-mm-yyyy (15-1)
 *   
 * - Others
 *   - today
 *   - tmr or tomorrow
 *
 * Supported time formats:
 * - 12-hour
 * 	- hh.mm am/pm
 * 	- hh:mm am/pm
 * 	- hh am/pm
 * 
 * - 24-hour
 *  - hh.mm
 *  - hh:mm
 *  - hhmm
 * 
 * Notes:
 * - If only time is specified and has passed for today,
 *   returned date will be for tomorrow at specified time.
 *   
 * - If only date is specified, default time is 11:59pm.
 * 
 * - If date specified is without year, and has passed for current year,
 *   return date will be for next year.
 *   
 * - If 29/2 is entered, return date is for next available year.
 *   If it is not a leap year, return 28/2.
 *   
 * - Short form for September is 'Sep' not 'Sept'
 */

public class DateParser {
	
	private Calendar calendar;
	
	// Indicates whether the year is included in user-entered date
	private boolean hasYear = false;
	
	// Indicates whether user-entered time is in 12-hour format
	private boolean is12Hour = false;
	
	// Hour and minutes parsed from user-entered time
	private int timeHour;
	private int timeMin;
	
	/* ***************
	 * Date formats *
	 ****************/
	
	// Format: dd/mm/yy or dd/mm/yyyy
	private static final String DATE_DMY_SLASH = "[0-3]?\\d/[01]?\\d/\\d{2}(\\d{2})?";
	
	// Format: dd.mm.yy or dd.mm.yyyy
	private static final String DATE_DMY_DOT = "[0-3]?\\d\\.[01]?\\d\\.\\d{2}(\\d{2})?";
	
	// Format: dd-mm-yy or dd-mm-yyyy
	private static final String DATE_DMY_DASH = "[0-3]?\\d-[01]?\\d-\\d{2}(\\d{2})?";
	
	// Format: dd/mm
	private static final String DATE_DM_SLASH = "[0-3]?\\d/[01]?\\d";
	
	// Format: dd.mm
	private static final String DATE_DM_DOT = "[0-3]?\\d\\.[01]?\\d";
	
	// Format: dd-mm
	private static final String DATE_DM_DASH = "[0-3]?\\d-[01]?\\d";
	
	// Format: ddmmmyy (short month)
	private static final String DATE_SHORT_DMY = "[0-3]?\\d[a-zA-Z]{3}\\d{2}(\\d{2})?";
	
	// Format: dd mmm yy (short month)
	private static final String DATE_SHORT_DMY_SPACE = "[0-3]?\\d\\s[a-zA-Z]{3}\\s\\d{2}(\\d{2})?";
	
	// Format: dd-mmm (short month)
	private static final String DATE_SHORT_DMY_DASH = "[0-3]?\\d-[a-zA-Z]{3}-\\d{2}(\\d{2})?";
	
	// Format: ddmmm (short month)
	private static final String DATE_SHORT_DM = "[0-3]?\\d[a-zA-Z]{3}";
	
	// Format: dd mmm (short month)
	private static final String DATE_SHORT_DM_SPACE = "[0-3]?\\d\\s[a-zA-Z]{3}";
	
	// Format: dd-mmm (short month)
	private static final String DATE_SHORT_DM_DASH = "[0-3]?\\d-[a-zA-Z]{3}";
	
	// Format: ddmmmm (full month)
	private static final String DATE_FULL_DMY = "[0-3]?\\d[a-zA-Z]{4,9}\\d{2}(\\d{2})?";

	// Format: dd mmmm (full month)
	private static final String DATE_FULL_DMY_SPACE = "[0-3]?\\d\\s[a-zA-Z]{4,9}\\s\\d{2}(\\d{2})?";

	// Format: dd-mmmm (full month)
	private static final String DATE_FULL_DMY_DASH = "[0-3]?\\d-[a-zA-Z]{4,9}-\\d{2}(\\d{2})?";

	// Format: ddmmmm (full month)
	private static final String DATE_FULL_DM = "[0-3]?\\d[a-zA-Z]{4,9}";
	
	// Format: dd mmmm (full month)
	private static final String DATE_FULL_DM_SPACE = "[0-3]?\\d\\s[a-zA-Z]{4,9}";
	
	// Format: dd-mmmm (full month)
	private static final String DATE_FULL_DM_DASH = "[0-3]?\\d-[a-zA-Z]{4,9}";
	
	// Format: Short day name
	private static final String DAY_SHORT = "(next\\s)?[a-zA-Z]{3,5}";
	
	// Format: Full day name
	private static final String DAY_FULL = "(next\\s)?[a-zA-Z]{6,9}";
	
	/* *************
	 * Time formats *
	 ****************/
	
	// Format: hh.mm am/pm (12-hour)
	private static final String TIME_12HM_DOT = "[01]?\\d\\.[0-5]\\d\\s?[aApP][mM]";
	
	// Format: hh:mm am/pm (12-hour)
	private static final String TIME_12HM_COLON = "[01]?\\d:[0-5]\\d\\s?[aApP][mM]";
	
	// Format: hh am/pm (12-hour)
	private static final String TIME_12H = "[01]?\\d\\s?[aApP][mM]";
	
	// Format: hh.mm (24-hour)
	private static final String TIME_24H_DOT = "[0-2]?\\d\\.[0-5]\\d";
	
	// Format: hh:mm (24-hour)
	private static final String TIME_24H_COLON = "[0-2]?\\d:[0-5]\\d";
	
	// Format hhmm (24-hour)
	private static final String TIME_24H = "[0-2]\\d[0-5]\\d";
	
	public DateParser() {
		calendar = Calendar.getInstance();
		timeHour = calendar.get(Calendar.HOUR_OF_DAY);
		timeMin = calendar.get(Calendar.MINUTE);
	}
	
	public Calendar getDate() {
		return calendar;
	}
	
	public Calendar parseDate(String rawDate) throws InvalidDateException {
		SimpleDateFormat sdf;
		calendar = Calendar.getInstance();
		
		if (rawDate.equalsIgnoreCase("today")) {
			return calendar;
			
		} else if (rawDate.equalsIgnoreCase("tomorrow") || rawDate.equalsIgnoreCase("tmr")) {
			calendar.add(Calendar.DATE, 1);
			return calendar;
			
		} else if (rawDate.matches(DAY_SHORT) || rawDate.matches(DAY_FULL)) {
			String[] d = rawDate.split(" ");
			String dayOfWeek;
			boolean isNextWeek = false;
			
			if (d.length == 1) {
				dayOfWeek = rawDate;
			} else if (d.length == 2 && d[0].equalsIgnoreCase("next")) {
				dayOfWeek = d[1].toLowerCase();
				isNextWeek = true;
			} else {
				throw new InvalidDateException("invalid date");
			}

			int taskDay = -1;
			int today = calendar.get(Calendar.DAY_OF_WEEK);

			if (dayOfWeek.equals("mon") || dayOfWeek.equals("monday")) {
				taskDay = Calendar.MONDAY;
			} else if (dayOfWeek.equals("tue") || dayOfWeek.equals("tues")
					   || dayOfWeek.equals("tuesday")) {
				taskDay = Calendar.TUESDAY;
			} else if (dayOfWeek.equals("wed") || dayOfWeek.equals("wednesday")) {
				taskDay = Calendar.WEDNESDAY;
			} else if (dayOfWeek.equals("thu") || dayOfWeek.equals("thur")
					   || dayOfWeek.equals("thurs") || dayOfWeek.equals("thursday")) {
				taskDay = Calendar.THURSDAY;
			} else if (dayOfWeek.equals("fri") || dayOfWeek.equals("friday")) {
				taskDay = Calendar.FRIDAY;
			} else if (dayOfWeek.equals("sat") || dayOfWeek.equals("saturday")) {
				taskDay = Calendar.SATURDAY;
			} else if (dayOfWeek.equals("sun") || dayOfWeek.equals("sunday")) {
				taskDay = Calendar.SUNDAY;
			}

			if (taskDay == -1) {
				throw new InvalidDateException("invalid date");
			} else {
				if (today > taskDay || isNextWeek) {
					calendar.add(Calendar.DATE, 7);
				}

				calendar.set(Calendar.DAY_OF_WEEK, taskDay);

				return calendar;
			}
			
		} else {
			/* ***********************
			 * Variations of dd mm yy *
			 *************************/
			if (rawDate.matches(DATE_DMY_SLASH)) {
				sdf = new SimpleDateFormat("dd/M/yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_DMY_DOT)) {
				sdf = new SimpleDateFormat("dd.M.yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_DMY_DASH)) {
				sdf = new SimpleDateFormat("dd-M-yy");
				hasYear = true;
			
			/* ********************
			 * Variations of dd mm *
			 **********************/ 
			} else if (rawDate.matches(DATE_DM_SLASH)) {
				rawDate += "/" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd/M/yy");
			} else if (rawDate.matches(DATE_DM_DOT)) {
				rawDate += "." + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd.M.yy");
			} else if (rawDate.matches(DATE_DM_DASH)) {
				rawDate += "-" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd-M-yy");
			
			/* ***************************************
			 * Variations of dd mmm yy (short month) *
			 *****************************************/
			} else if (rawDate.matches(DATE_SHORT_DMY)) {
				sdf = new SimpleDateFormat("ddMMMyy");
				hasYear = true;
			} else if (rawDate.matches(DATE_SHORT_DMY_SPACE)) {
				sdf = new SimpleDateFormat("dd MMM yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_SHORT_DMY_DASH)) {
				sdf = new SimpleDateFormat("dd-MMM-yy");
				hasYear = true;
			
			/* ************************************
			 * Variations of dd mmm (short month) *
			 **************************************/
			} else if (rawDate.matches(DATE_SHORT_DM)) {
				rawDate += calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("ddMMMyy");
			} else if (rawDate.matches(DATE_SHORT_DM_SPACE)) {
				rawDate += " " + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd MMM yy");
			} else if (rawDate.matches(DATE_SHORT_DM_DASH)) {
				rawDate += "-" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd-MMM-yy");
				
			/* ***************************************
			 * Variations of dd mmmm yy (long month) *
			 *****************************************/
			} else if (rawDate.matches(DATE_FULL_DMY)) {
				sdf = new SimpleDateFormat("ddMMMMyy");
				hasYear = true;
			} else if (rawDate.matches(DATE_FULL_DMY_SPACE)) {
				sdf = new SimpleDateFormat("dd MMMM yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_FULL_DMY_DASH)) {
				sdf = new SimpleDateFormat("dd-MMMM-yy");
				hasYear = true;
				
			/* ************************************
			 * Variations of dd mmmm (long month) *
			 **************************************/
			} else if (rawDate.matches(DATE_FULL_DM)) {
				rawDate += calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("ddMMMMyy");
			} else if (rawDate.matches(DATE_FULL_DM_SPACE)) {
				rawDate += " " + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd MMMM yy");
			} else if (rawDate.matches(DATE_FULL_DM_DASH)) {
				rawDate += "-" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd-MMMM-yy");
				
			// Unrecognised date
			} else {
				throw new InvalidDateException("invalid date");
			}

			sdf.setLenient(false);
			
			try {
				Date date = sdf.parse(rawDate);
				calendar.setTime(date);
				
				if (!hasYear && isPastDate()) {
					calendar.add(Calendar.YEAR, 1);
				}
				
				return calendar;
			} catch (ParseException e) {
				throw new InvalidDateException("invalid date");
			}				
		}
	}
	
	public Calendar parseTime(String rawTime) throws InvalidDateException {
		calendar = Calendar.getInstance();
		is12Hour = false;
		
		/* ****************************
		 * Variations of 12-hour time *
		 ******************************/
		if (rawTime.matches(TIME_12HM_DOT)) {
			int dotPos = rawTime.indexOf(".");
			timeHour = Integer.parseInt(rawTime.substring(0, dotPos));
			timeMin = Integer.parseInt(rawTime.substring(dotPos + 1, dotPos + 3));
			is12Hour = true;
		} else if (rawTime.matches(TIME_12HM_COLON)) {
			int colonPos = rawTime.indexOf(":");
			timeHour = Integer.parseInt(rawTime.substring(0, colonPos));
			timeMin = Integer.parseInt(rawTime.substring(colonPos + 1, colonPos + 3));
			is12Hour = true;
		} else if (rawTime.matches(TIME_12H)) {
			timeHour = Integer.parseInt(rawTime.split("\\s?[aApP]")[0]);
			timeMin = 0;
			is12Hour = true;
			
		/* ****************************
		 * Variations of 24-hour time *
		 ******************************/
		} else if (rawTime.matches(TIME_24H_DOT)) {
			int dotPos = rawTime.indexOf(".");
			timeHour = Integer.parseInt(rawTime.substring(0, dotPos));
			timeMin = Integer.parseInt(rawTime.substring(dotPos + 1, dotPos + 3));
		} else if (rawTime.matches(TIME_24H_COLON)) {
			int colonPos = rawTime.indexOf(":");
			timeHour = Integer.parseInt(rawTime.substring(0, colonPos));
			timeMin = Integer.parseInt(rawTime.substring(colonPos + 1, colonPos + 3));
		} else if (rawTime.matches(TIME_24H)) {
			timeHour = Integer.parseInt(rawTime.substring(0, 2));
			timeMin = Integer.parseInt(rawTime.substring(2, rawTime.length()));
			
		// Unrecognised time
		} else {
			throw new InvalidDateException("invalid time");
		}
		
		// Conversion to 24-hour time
		if (is12Hour) {
			// Check if time is valid
			if (timeHour == 0) {
				throw new InvalidDateException("invalid time");
			}
			
			if (isPm(rawTime)) {
				if (timeHour != 12) {
					timeHour += 12;
				}
			} else {
				if (timeHour == 12) {
					timeHour = 0;
				}
			}
		}
		
		// Check if time is valid
		if (timeHour > 23) {
			throw new InvalidDateException("invalid time");
		}
		
		calendar.set(Calendar.HOUR_OF_DAY, timeHour);
		calendar.set(Calendar.MINUTE, timeMin);
		return calendar;
	}
	
	// Check if date entered has passed for current year
	private boolean isPastDate() {
		Calendar c = Calendar.getInstance();
		c.add(Calendar.DATE, -1);
		return calendar.before(c);
	}

	
	// Check if time of day is am or pm
	private boolean isPm(String time) {
		String timeOfDay = time.substring(time.length() - 2, time.length());
		return timeOfDay.equalsIgnoreCase("pm");
	}
	
	// Check if date has passed
	public boolean hasDatePassed(Calendar date, Calendar time) {
		Calendar curr = Calendar.getInstance();
		Calendar combined = combineDateTime(date, time);
		return combined.before(curr);
	}
	
	// Combines date and time into a single Calendar
	public Calendar combineDateTime(Calendar date, Calendar time) {
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.YEAR, date.get(Calendar.YEAR));
		c.set(Calendar.MONTH, date.get(Calendar.MONTH));
		c.set(Calendar.DATE, date.get(Calendar.DATE));
		
		c.set(Calendar.HOUR_OF_DAY, time.get(Calendar.HOUR_OF_DAY));
		c.set(Calendar.MINUTE, time.get(Calendar.MINUTE));
		
		return c;
	}
	
	public Calendar getDefaultStartTime() {
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		
		return c;
	}
	
	public Calendar getDefaultEndTime() {
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.HOUR_OF_DAY, 23);
		c.set(Calendar.MINUTE, 59);
		
		return c;
	}
	
	public Calendar getDefaultDate() {
		return Calendar.getInstance();
	}
	
	public Calendar getNextDay(Calendar c) {
		Calendar next = c;
		next.add(Calendar.DATE, 1);
		
		return next;
	}
}
```
###### \src\tucklife\parser\InvalidDateException.java
``` java
package tucklife.parser;

public class InvalidDateException extends Exception {
	
	public InvalidDateException(String errorMsg) {
		super(errorMsg);
	}
}
```
###### \src\tucklife\parser\Parser.java
``` java
package tucklife.parser;

import java.util.Calendar;
import java.util.Hashtable;

public class Parser {
	
	private String[] commandTypes = { "add", "change", "complete", "delete", "demo", "display", "displaydone",
									  "edit", "exit", "help", "queue", "redo", "save", "saveto", "setlimit", "undo" };
	private String paramSymbols = "-+$#!&@";
	private ProtoTask pt;
	private DateParser dp;
	private Hashtable<String, String> commandTable;
	
	// Error messages:
	private final String ERROR_PARAMS_NONE = "Format: %1$s";
	private final String ERROR_PARAMS_ID = "Format: %1$s <id>";
	private final String ERROR_PARAMS_ADD = "Format: add <task description> (optional: $<date> "
										  + "+<time> #<category> !<priority> @<location> &<additional>)";
	private final String ERROR_PARAMS_EDIT = "Format: edit <id> (optional: <task description> "
										   + "$<date> +<time> #<category> !<priority> @<location> &<additional>)";
	private final String ERROR_PARAMS_DISPLAY = "Format: display (optional: <search term> +/-<sort order>)";
	private final String ERROR_PARAMS_QUEUE = "Format: queue <id> <pos>";
	private final String ERROR_PARAMS_DEMO = "Format: demo <command>";
	private final String ERROR_PARAMS_LIMIT = "Format: setlimit <limit>";
	private final String ERROR_PARAMS_SAVETO = "Format: saveto <file path>";
	private final String ERROR_PARAMS_CHANGE = "Format: change <old command> <new command>";
	
	private final String ERROR_INVALID_PARAMS = "Incorrect number of parameters";
	private final String ERROR_INVALID_COMMAND = "'%1$s' is not a valid command";

	public Parser() {
	}
	
	/**
	 * This method takes in a user input command and parses it into a ProtoTask object
	 * 
	 * @param command User input command.
	 * @return ProtoTask with the relevant parameters.
	 */
	public ProtoTask parse(String command) {
		String commandAlias = getFirstWord(command).toLowerCase();
		String commandArgument = getRemainingArgument(command);
		
		if (isValidCommandAlias(commandAlias)) {
			// Convert from custom alias to standard command type
			String commandType = getCommandType(commandAlias);
			
			pt = new ProtoTask(commandType);
			parseParameters(commandType, commandArgument);
		} else {
			// Unrecognized command type
			createErrorTask(String.format(ERROR_INVALID_COMMAND, commandAlias));
		}
		
		return pt;
	}
	
	/**
	 * This method extracts the first word (space delimited) from the user command.
	 * It returns the entire command if the command is a single word.
	 * 
	 * @param command User input command.
	 * @return First word in the command.
	 */
	private String getFirstWord(String command) {
		int i = command.indexOf(" ");
		
		if (i == -1) {
			return command;
		} else {
			return command.substring(0, i);
		}
	}
	
	/**
	 * This method extracts the remainder of the user command without the first word.
	 * It returns an empty string if the command is a single word.
	 * 
	 * @param command User input command.
	 * @return Command without the first word.
	 */
	private String getRemainingArgument(String command) {
		int i = command.indexOf(" ");
		
		if (i == -1) {
			return "";
		} else {
			return command.substring(i + 1, command.length());
		}
	}
	
	/**
	 * This method checks whether the command alias refers to a valid command.
	 * 
	 * @param alias Command alias.
	 * @return True if alias is valid, false otherwise.
	 */
	private boolean isValidCommandAlias(String alias) {
		if (commandTable.contains(alias)) {
			return true;
		} else {
			return isValidCommandType(alias);
		}
	}
	
	/**
	 * This method checks whether the type of command is valid.
	 * 
	 * @param commandType Type of command.
	 * @return True if command type is valid, false otherwise.
	 */
	private boolean isValidCommandType(String commandType) {
		for (String type:commandTypes) {
			if (commandType.equals(type)) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * This method converts a command alias into the standard command type.
	 * 
	 * @param alias Command alias.
	 * @return Type of command if alias is found, "error" otherwise (should not happen).
	 */
	private String getCommandType(String alias) {
		for (String key:commandTypes) {
			if (alias.equals(key) || alias.equals(commandTable.get(key))) {
				return key;
			}
		}
		
		// Should not be reachable
		return "error";
	}
	
	/**
	 * This method parses the parameters based on the command type and
	 * adds the parameters into a ProtoTask object. If any of the parameters are
	 * invalid, it creates an error ProtoTask.
	 * 
	 * @param commandType Type of command.
	 * @param commandArg String of all the parameters for the command.
	 */
	private void parseParameters(String commandType, String commandArg) {
		switch (commandType) {
			case "edit" :
				if (commandArg.isEmpty() || getRemainingArgument(commandArg).isEmpty()) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_EDIT);
					break;
				} else if (!isInteger(getFirstWord(commandArg)) || Integer.parseInt(getFirstWord(commandArg)) <= 0) {
					createErrorTask("<id> must be greater than 0\n" + ERROR_PARAMS_EDIT);
					break;
				} else {
					pt.setId(Integer.parseInt(getFirstWord(commandArg)));
					commandArg = getRemainingArgument(commandArg);
				}
				
				// No break, edit and add share similar parameters
				
			case "add" :
				if (commandArg.isEmpty()) {
						createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_ADD);
				} else {
					String taskDesc = extractParameter("", commandArg);
					
					if (!taskDesc.isEmpty()) {
						pt.setTaskDesc(taskDesc);
					} else if (commandType.equals("add")) {
						createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_ADD);
						break;
					}
					
					String location = extractParameter("@", commandArg);
					String priority = extractParameter("!", commandArg);
					String cat = extractParameter("#", commandArg);
					String time = extractParameter("+", commandArg);
					String date = extractParameter("$", commandArg);
					String additional = extractParameter("&", commandArg);
					
					if (!location.isEmpty()) {
						pt.setLocation(location);
					}
					
					if (!priority.isEmpty()) {
						int priorityRank = convertPriority(priority);
						
						if (priorityRank == -1) {
							createErrorTask("invalid priority");
							break;
						} else {
							pt.setPriority(priorityRank);
						}
						
					}
					
					if (!cat.isEmpty()) {
						pt.setCategory(cat);
					}
					
					if (!time.isEmpty() || !date.isEmpty()) {
						dp = new DateParser();
						Calendar startDate = null;
						Calendar startTime = null;
						Calendar endDate = null;
						Calendar endTime = null;
						String[] times, dates;
						
						try {
							if (time.isEmpty()) {
								// Time not specified
								dates = splitEventDate(date);
								
								if (dates.length == 1) {
									// Deadline
									endDate = dp.combineDateTime(dp.parseDate(date), dp.getDefaultEndTime());

								} else if (dates.length == 2) {
									// Event
									startDate = dp.combineDateTime(dp.parseDate(dates[0]), dp.getDefaultStartTime());
									endDate = dp.combineDateTime(dp.parseDate(dates[1]), dp.getDefaultEndTime());
									
								} else {
									// Unrecognized format
									createErrorTask("invalid date");
									break;
								}
							} else if (date.isEmpty()) {
								// Date not specified
								times = splitEventDate(time);
								
								if (times.length == 1) {
									// Deadline
									if (commandType.equals("edit"))  {
										endTime = dp.parseTime(time);
									} else {
										endDate = dp.getDefaultDate();

										if (dp.hasDatePassed(endDate, dp.parseTime(time))) {
											endDate = dp.getNextDay(endDate);
										}

										endDate = dp.combineDateTime(endDate, dp.parseTime(time));
									}
									
								} else if (times.length == 2) {
									// Event
									if (commandType.equals("edit")) {
										startTime = dp.parseTime(times[0]);
										endTime = dp.parseTime(times[1]);
									} else {
										startDate = dp.getDefaultDate();
										
										if (dp.hasDatePassed(startDate, dp.parseTime(times[0]))) {
											startDate = dp.getNextDay(startDate);
										}
										
										endDate = startDate;
										startDate = dp.combineDateTime(startDate, dp.parseTime(times[0]));
										endDate = dp.combineDateTime(endDate, dp.parseTime(times[1])); 
									}
									
								} else {
									// Unrecognized format
									createErrorTask("invalid time");
									break;
								}
							} else {
								dates = splitEventDate(date);
								times = splitEventDate(time);
								
								if (dates.length == times.length) {
									if (dates.length == 1) {
										// Deadline
										endDate = dp.combineDateTime(dp.parseDate(date), dp.parseTime(time));
										
										if (commandType.equals("edit")) {
											endTime = dp.parseTime(time);
										}
										
									} else if (dates.length == 2) {
										// Multiple day event
										startDate = dp.combineDateTime(dp.parseDate(dates[0]), dp.parseTime(times[0]));
										endDate = dp.combineDateTime(dp.parseDate(dates[1]), dp.parseTime(times[1]));
										
										if (commandType.equals("edit")) {
											startTime = dp.parseTime(times[0]);
											endTime = dp.parseTime(times[1]);
										}
										
									} else {
										// Unrecognized format
										createErrorTask("invalid event format");
										break;
									}
								} else if (dates.length == 1 && times.length == 2) {
									// Same day event
									startDate = dp.combineDateTime(dp.parseDate(date), dp.parseTime(times[0]));
									endDate = dp.combineDateTime(dp.parseDate(date), dp.parseTime(times[1]));
									
									if (commandType.equals("edit")) {
										startTime = dp.parseTime(times[0]);
										endTime = dp.parseTime(times[1]);
									}
									
								} else {
									// Unrecognized format
									createErrorTask("invalid event format");
									break;
								}
							}
							
							// Setting the parameters in ProtoTask
							if (startDate != null) {
								pt.setStartDate(startDate);
							}
							
							if (startTime != null) {
								pt.setStartTime(startTime);
							}
							
							if (endDate != null) {
								pt.setEndDate(endDate);
							}
							
							if (endTime != null) {
								pt.setEndTime(endTime);
							}
						} catch (InvalidDateException e) {
							createErrorTask(e.getMessage());
							break;
						}
					}
					
					if (!additional.isEmpty()) {
						pt.setAdditional(additional);
					}
				}
				break;
				
			// Parameter: id
			case "complete" :
			case "delete" :
				if (commandArg.isEmpty()) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_ID);
				} else if (!isInteger(commandArg) || Integer.parseInt(commandArg) <= 0) {
					createErrorTask("'id' must be a positive integer");
				} else {
					pt.setId(Integer.parseInt(commandArg));
				}
				break;
				
			// Parameter: task limit
			case "setlimit" :
				if (commandArg.isEmpty()) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_LIMIT);
				} else if (!isInteger(commandArg) || Integer.parseInt(commandArg) < 0) {
					createErrorTask("limit must be a non-negative integer");
				} else {
					pt.setLimit(Integer.parseInt(commandArg));
				}
				break;
				
			// Parameter: id, position
			case "queue" :
				String[] splitParams = commandArg.split(" ");
				if (splitParams.length != 1 && splitParams.length != 2) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_QUEUE);
				} else if (isInteger(splitParams[0]) && Integer.parseInt(splitParams[0]) > 0) {
					if (splitParams.length == 2) {
						if (isInteger(splitParams[1]) && Integer.parseInt(splitParams[1]) > 0) {
							pt.setPosition(Integer.parseInt(splitParams[1]));
						} else {
							createErrorTask("position must be a non-negative integer");
							break;
						}
					}
					
					pt.setId(Integer.parseInt(splitParams[0]));
				} else {
					createErrorTask("id must be a non-negative integer");
				}
				break;
				
			// Parameter: command
			case "demo" :
				if (isValidCommandAlias(commandArg)) {
					pt.setDemoCommand(commandArg);
				} else {
					if (commandArg.isEmpty()) {
						createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_DEMO);
					} else {
						createErrorTask("'" + commandArg + "' is not a valid command");
					}
				}
				break;
			
			// Parameter: old command, new command
			case "change" :
				String[] commands = commandArg.split(" ");
				if (commands.length != 2) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_CHANGE);
				} else {
					String oldCommand = commands[0];
					String newCommand = commands[1];
					
					if (isValidCommandAlias(oldCommand)) {
						if (isValidCommandAlias(newCommand)) {
							createErrorTask("'" + newCommand + "' is a reserved command alias / type");
						} else {
							String type = getCommandType(oldCommand);
							commandTable.put(type, newCommand);
							pt.setChangeMessage("'" + type + "' has been changed to '" + newCommand + "'!");
						}
					} else {
						createErrorTask("'" + oldCommand + "' is not a valid command");
					}
				}
				break;

			case "display" :
				if (isInteger(commandArg) && Integer.parseInt(commandArg) > 0) {
					pt.setId(Integer.parseInt(commandArg));
					break;
				}

				// No break, display and displaydone have similar parameters

			case "displaydone" :
				String search = extractParameter("", commandArg);
				if (!search.isEmpty()) {
					pt.setSearchKey(search);
				}
				
				boolean hasSortOrder = false;
				boolean isAscending = false;
				String sortBy = extractParameter("+", commandArg);
				
				if (!sortBy.isEmpty()) {
					isAscending = true;
					hasSortOrder = true;
				} else {
					sortBy = extractParameter("-", commandArg);
					
					if (!sortBy.isEmpty()) {
						isAscending = false;
						hasSortOrder = true;
					}
				}
				
				if (hasSortOrder) {
					if (isValidSortCrit(sortBy)) {
						pt.setHasSortOrder(true);
						pt.setIsAscending(isAscending);
						pt.setSortCrit(sortBy);
					} else {
						createErrorTask("invalid sort parameters");
					}
				}
				
				break;

			// Parameter: file path
			case "saveto" :
				if (commandArg.isEmpty()) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_SAVETO);
				} else {
					pt.setPath(commandArg);
				}
				break;
				
			// No parameters
			case "undo" :
			case "redo" :
			case "help" :
			case "save" :
			case "exit" :
				if (!commandArg.isEmpty()) {
					createErrorTask(ERROR_INVALID_PARAMS + "\n"
				                    + String.format(ERROR_PARAMS_NONE, commandType));
				}
				break;
		}
	}
	
	private String extractParameter(String symbol, String commandArg) {
		boolean toCheck = true;
		boolean isInParam = false;
		String parameter = "";
		char symbolChar = ' ';

		if (symbol.isEmpty()) {
			isInParam = true;
		} else {
			symbolChar = symbol.charAt(0);
		}

		for (int i = 0; i < commandArg.length(); i++) {
			if (commandArg.charAt(i) == '"') {
				toCheck = !toCheck;
			} else {

				if (isInParam) {
					if (toCheck && commandArg.charAt(i) == ' ' && i + 1 != commandArg.length()) {
						if (paramSymbols.contains(commandArg.charAt(i + 1) + "")) {
							isInParam = false;
							break;
						} else {
							parameter += commandArg.charAt(i);
						}
					} else {
						parameter += commandArg.charAt(i);
					}
				} else {				
					if (toCheck && commandArg.charAt(i) == symbolChar) {
						if (i == 0 || commandArg.charAt(i - 1) == ' ') {
							isInParam = true;
						}
					}
				}
			}
		}
		
		return parameter;
	}
	
	/*
	private String extractParameter(String symbol, String commandArg) {
		// Parameter symbol must be at the start of command argument
		// or have a space preceding it to be valid
		if (!commandArg.contains(symbol)) {
			// Parameter not provided
			return "";
		} else if (commandArg.indexOf(symbol) == 0) {
			if (!symbol.isEmpty()) {
				commandArg = commandArg.substring(1, commandArg.length());
			}
		} else if (!commandArg.contains(" " + symbol)) {
			return "";
		} else {
			commandArg = commandArg.substring(commandArg.indexOf(" " + symbol) + 2, commandArg.length());
		}
		
		if (commandArg.isEmpty()) {
			// Use default parameter
			return "";
		}
		
		int splitPoint = -1;
		for (int i = 0; i < paramSymbols.length; i++) {
			if (commandArg.indexOf(paramSymbols[i]) == 0) {
				if (symbol.isEmpty()) {
					// No description
					splitPoint = 0;
				} else if (commandArg.length() == 1){
					// For sorting
					splitPoint = 1;
				}
				break;
			} else if (commandArg.contains(" " + paramSymbols[i])) {
				if (i == 0) {
					if (symbol.equals("-")) {
						int index = commandArg.indexOf(" " + paramSymbols[i]);

						if (splitPoint == -1 || splitPoint > index) {
							splitPoint = index;
						}
					}
				} else {
					int index = commandArg.indexOf(" " + paramSymbols[i]);

					if (splitPoint == -1 || splitPoint > index) {
						splitPoint = index;
					}
				}
			}
		}

		if (splitPoint == -1) {
			return commandArg.substring(0, commandArg.length());
		} else {
			return commandArg.substring(0, splitPoint);
		}
	}
	*/
	
	private boolean isInteger(String s) {
		boolean isInt = true;
		
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException nfe) {
			isInt = false;
		}
		
		return isInt;
	}
	
	private int convertPriority(String priority) {
		if (priority.equalsIgnoreCase("high")) {
			return 1;
		} else if (priority.equalsIgnoreCase("medium")) {
			return 2;
		} else if (priority.equalsIgnoreCase("low")) {
			return 3;
		} else {
			return -1;
		}
	}
	
	private void createErrorTask(String errorMsg) {
		pt = new ProtoTask("error");
		pt.setErrorMessage(errorMsg);
	}
	
	private boolean isValidSortCrit(String sortParam) {
		return paramSymbols.substring(1).contains(sortParam);
	}
	
	private String[] splitEventDate(String s) {
		String[] result;
		if (s.contains(" - ")) {
			result = s.split("\\s-\\s");
		} else if (s.contains(" to ")) {
			result = s.split("\\sto\\s");
		} else {
			String[] ss = {s};
			return ss;
		}
		
		if (result[0].startsWith("next") && !result[1].startsWith("next")) {
			result[1] = "next " + result[1];
		}
		
		return result;
	}
	
	private void parseCommandWithoutParam(String command, String arg) {
		if (!arg.isEmpty()) {
			createErrorTask(ERROR_INVALID_PARAMS + "\n"
		                    + String.format(ERROR_PARAMS_NONE, command));
		}
	}
	
	public Hashtable<String, String> getCommands() {
		return commandTable;
	}
	
	public void loadCommands(Hashtable<String, String> ht) {
		commandTable = ht;
	}
}
```
###### \src\tucklife\parser\ParserTest.java
``` java
package tucklife.parser;

import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Hashtable;

import org.junit.Before;
import org.junit.Test;

public class ParserTest {
	
	Parser p;
	ProtoTask pt;

	@Before
	public void setUp() throws Exception {
		p = new Parser();
		p.loadCommands(new Hashtable<String, String>());
	}

	@Test
	public void testAdd() {
		// 0 parameters
		assertTrue(p.parse("add").isError());
		
		// No task description
		assertTrue(p.parse("add !high").isError());
		
		// Task description
		assertEquals("Command type: add\nParameters:\nTask description: work\n",
					 p.parse("add work").toString());
		assertEquals("Command type: add\nParameters:\nTask description: finish all my work!\n",
					 p.parse("add finish all my work!").toString());
		assertEquals("Command type: add\nParameters:\nTask description: 123\n",
					 p.parse("add 123").toString());
		
		// Location - @
		assertEquals("Command type: add\nParameters:\nTask description: work\nLocation: office\n",
					 p.parse("add work @office").toString());
		assertEquals("Command type: add\nParameters:\nTask description: dinner\nLocation: atas restaurant\n",
					 p.parse("add dinner @atas restaurant").toString());
		
		// Priority - !
		assertEquals("Command type: add\nParameters:\nTask description: very important task\nPriority: 1\n",
					 p.parse("add very important task !high").toString());
		assertEquals("Command type: add\nParameters:\nTask description: normal task\nPriority: 2\n",
				 	 p.parse("add normal task !medium").toString());
		assertEquals("Command type: add\nParameters:\nTask description: optional task\nPriority: 3\n",
				 	 p.parse("add optional task !low").toString());
		
		// Invalid priority
		assertTrue(p.parse("add invalid priority !extremely important").isError());
		
		// Category - #
		assertEquals("Command type: add\nParameters:\nTask description: unit testing\nCategory: CS2103T\n",
					 p.parse("add unit testing #CS2103T").toString());
		assertEquals("Command type: add\nParameters:\nTask description: do report\nCategory: top secret project\n",
					 p.parse("add do report #top secret project").toString());
		
		// Additional information - &
		assertEquals("Command type: add\nParameters:\nTask description: dinner with mum\n"
					 + "Additional information: sushi! :D\n",
					 p.parse("add dinner with mum &sushi! :D").toString());
		assertEquals("Command type: add\nParameters:\nTask description: meeting\n"
					 + "Additional information: about sales performance. Prepare to present.\n",
					 p.parse("add meeting &about sales performance. Prepare to present.").toString());
		
		// Date - $
		// Single date
		assertEquals("Command type: add\nParameters:\nTask description: job interview\n"
					 + "End date: Wed, 25 May 2016\nEnd time: 23:59\n",
					 p.parse("add job interview $25/5/16").toString());
		
		// Invalid dates
		assertTrue(p.parse("add my birthday $30 feb").isError());
		assertTrue(p.parse("add task $not a date").isError());
		
		// Event dates
		// Using to
		assertEquals("Command type: add\nParameters:\nTask description: work trip\n"
					 + "Start date: Mon, 23 May 2016\nStart time: 00:00\n"
					 + "End date: Fri, 27 May 2016\nEnd time: 23:59\n",
					 p.parse("add work trip $23may to 27may").toString());
		
		// Using dash
		assertEquals("Command type: add\nParameters:\nTask description: work trip\n"
					 + "Start date: Mon, 23 May 2016\nStart time: 00:00\n"
					 + "End date: Fri, 27 May 2016\nEnd time: 23:59\n",
					 p.parse("add work trip $23may - 27may").toString());
		
		// Invalid event dates
		assertTrue(p.parse("add some event $29 feb - 30 feb").isError());
		assertTrue(p.parse("add task $30 feb - 1 mar").isError());
		
		// Time - +
		// Getting the correct date based on current date
		Calendar c = Calendar.getInstance();
		if (c.get(Calendar.HOUR_OF_DAY) > 16) {
			c.add(Calendar.DATE, 1);
		}
		c.set(Calendar.HOUR_OF_DAY, 17);
		c.set(Calendar.MINUTE, 0);
		
		assertEquals("Command type: add\nParameters:\nTask description: evening run\nEnd date: "
					 + new SimpleDateFormat("EEE, dd MMM yyyy").format(c.getTime()) + "\nEnd time: "
					 + new SimpleDateFormat("HH:mm").format(c.getTime()) + "\n",
					 p.parse("add evening run +5pm").toString());
		
		// Invalid times
		assertTrue(p.parse("add 13 o'clock +13pm").isError());
		assertTrue(p.parse("add task +not a time").isError());
		
		// All parameters
		assertEquals("Command type: add\nParameters:\nTask description: meeting with boss\n"
					 + "Location: boss's office\nCategory: top secret project\nAdditional information: "
					 + "BIG BOSS COMING!!!\nPriority: 1\nEnd date: Sat, 28 May 2016\nEnd time: 10:00\n",
					 p.parse("add meeting with boss !high +10am $28-may-2016 @boss's office"
							 + " &BIG BOSS COMING!!! #top secret project").toString());
		
		// Some parameters
		assertEquals("Command type: add\nParameters:\nTask description: buy office supplies\n"
					 + "Category: misc\nPriority: 2\nEnd date: Tue, 24 May 2016\nEnd time: 23:59\n",
					 p.parse("add buy office supplies $24 may 16 #misc !medium").toString());
	}
	
	@Test
	public void testComplete() {
		// 0 parameters
		assertTrue(p.parse("complete").isError());

		// 1 parameter

		// ID not a number
		assertTrue(p.parse("complete abc").isError());

		// ID < 1
		assertTrue(p.parse("complete -1").isError());

		// ID >= 1
		assertEquals("Command type: complete\nParameters:\nID: 5\n", p.parse("complete 5").toString());

		// Boundary
		assertTrue(p.parse("complete 0").isError());
		assertEquals("Command type: complete\nParameters:\nID: 1\n", p.parse("complete 1").toString());
		assertEquals("Command type: complete\nParameters:\nID: 2\n", p.parse("complete 2").toString());

		// > 1 parameter
		assertTrue(p.parse("complete 1 1").isError());
	}

	@Test
	public void testDelete() {
		// 0 parameters
		assertTrue(p.parse("delete").isError());

		// 1 parameter

		// ID not a number
		assertTrue(p.parse("delete abc").isError());

		// ID < 1
		assertTrue(p.parse("delete -1").isError());

		// ID >= 1
		assertEquals("Command type: delete\nParameters:\nID: 5\n", p.parse("delete 5").toString());

		// Boundary
		assertTrue(p.parse("delete 0").isError());
		assertEquals("Command type: delete\nParameters:\nID: 1\n", p.parse("delete 1").toString());
		assertEquals("Command type: delete\nParameters:\nID: 2\n", p.parse("delete 2").toString());

		// > 1 parameter
		assertTrue(p.parse("delete 1 1").isError());
	}
	
	@Test
	public void testDemo() {
		// 0 parameters
		assertTrue(p.parse("demo").isError());
		
		// 1 parameter
		
		// Invalid command
		assertTrue(p.parse("demo notacommand").isError());
		
		// Valid command
		assertEquals("Command type: demo\nParameters:\nDemo command: add\n", p.parse("demo add").toString());
		assertEquals("Command type: demo\nParameters:\nDemo command: help\n", p.parse("demo help").toString());
		assertEquals("Command type: demo\nParameters:\nDemo command: undo\n", p.parse("demo undo").toString());
		
		// > 1 parameter
		assertTrue(p.parse("demo demo demo").isError());
	}
	
	@Test
	public void testDisplay() {
		// 0 parameters
		assertEquals("Command type: display\nParameters:\n", p.parse("display").toString());
		
		//TODO
	}
	
	@Test
	public void testDisplaydone() {
		// 0 parameters
		assertEquals("Command type: displaydone\nParameters:\n", p.parse("displaydone").toString());
		
		//TODO
	}
	
	@Test
	public void testEdit() {
		// 0 parameters
		assertTrue(p.parse("edit").isError());

		// 1 parameter
		assertTrue(p.parse("edit !high").isError());
		assertTrue(p.parse("edit 1").isError());
		
		// > 1 parameter
		
		// ID is not a number
		assertTrue(p.parse("edit something here").isError());
		
		// ID < 1
		assertTrue(p.parse("edit -1 new task name").isError());
		
		// ID >= 1

		// Task description
		assertEquals("Command type: edit\nParameters:\nTask description: work\nID: 1\n",
					 p.parse("edit 1 work").toString());
		assertEquals("Command type: edit\nParameters:\nTask description: finish all my work!\nID: 1\n",
					 p.parse("edit 1 finish all my work!").toString());
		assertEquals("Command type: edit\nParameters:\nTask description: 123\nID: 1\n",
				 	 p.parse("edit 1 123").toString());

		// Location - @
		assertEquals("Command type: edit\nParameters:\nLocation: office\nID: 1\n",
					 p.parse("edit 1 @office").toString());
		assertEquals("Command type: edit\nParameters:\nLocation: atas restaurant\nID: 1\n",
					 p.parse("edit 1 @atas restaurant").toString());

		// Priority - !
		assertEquals("Command type: edit\nParameters:\nPriority: 1\nID: 1\n",
					 p.parse("edit 1 !high").toString());
		assertEquals("Command type: edit\nParameters:\nPriority: 2\nID: 1\n",
					 p.parse("edit 1 !medium").toString());
		assertEquals("Command type: edit\nParameters:\nPriority: 3\nID: 1\n",
					 p.parse("edit 1 !low").toString());

		// Invalid priority
		assertTrue(p.parse("edit 1 !extremely important").isError());

		// Category - #
		assertEquals("Command type: edit\nParameters:\nCategory: CS2103T\nID: 1\n",
					 p.parse("edit 1 #CS2103T").toString());
		assertEquals("Command type: edit\nParameters:\nCategory: top secret project\nID: 1\n",
					 p.parse("edit 1 #top secret project").toString());

		// Additional information - &
		assertEquals("Command type: edit\nParameters:\nAdditional information: sushi! :D\nID: 15\n",
					 p.parse("edit 15 &sushi! :D").toString());
		assertEquals("Command type: edit\nParameters:\nAdditional information: about sales performance. "
					 + "Prepare to present.\nID: 15\n",
					 p.parse("edit 15 &about sales performance. Prepare to present.").toString());

		// Date - $
		assertEquals("Command type: edit\nParameters:\nID: 15\nEnd date: Wed, 25 May 2016\n",
					 p.parse("edit 15 $25/5/16").toString());

		// Invalid dates
		assertTrue(p.parse("edit 15 $30 feb").isError());
		assertTrue(p.parse("edit 15 $not a date").isError());

		// Time - +
		assertEquals("Command type: edit\nParameters:\nID: 15\nEnd time: 17:00\n",
					 p.parse("edit 15 +5pm").toString());

		// Invalid times
		assertTrue(p.parse("edit 15 +13pm").isError());
		assertTrue(p.parse("edit 15 +not a time").isError());

		// All parameters
		assertEquals("Command type: edit\nParameters:\nTask description: meeting with boss\n"
					 + "Location: boss's office\nCategory: top secret project\nAdditional information: "
					 + "BIG BOSS COMING!!!\nPriority: 1\nID: 15\nEnd date: Sat, 28 May 2016\nEnd time: 10:00\n",
					 p.parse("edit 15 meeting with boss !high +10am $28-may-2016 @boss's office"
							 + " &BIG BOSS COMING!!! #top secret project").toString());

		// Some parameters
		assertEquals("Command type: edit\nParameters:\nCategory: misc\n"
					 + "Priority: 2\nID: 15\nEnd date: Tue, 24 May 2016\n",
					 p.parse("edit 15 $24 may 16 #misc !medium").toString());
	}
	
	@Test
	public void testExit() {
		// 0 parameters
		assertEquals("Command type: exit\nParameters:\n", p.parse("exit").toString());
		
		// Has parameters
		assertTrue(p.parse("exit 1").isError());
	}
	
	@Test
	public void testHelp() {
		// 0 parameters
		assertEquals("Command type: help\nParameters:\n", p.parse("help").toString());

		// Has parameters
		assertTrue(p.parse("help me").isError());
	}
	
	@Test
	public void testQueue() {
		// 0 parameters
		assertTrue(p.parse("queue").isError());
		
		// 1 parameter
		
		// ID not a number
		assertTrue(p.parse("queue up").isError());
		
		// ID < 1
		assertTrue(p.parse("queue -1").isError());
		
		// ID >= 1
		assertEquals("Command type: queue\nParameters:\nID: 5\n", p.parse("queue 5").toString());
		
		// Boundary
		assertTrue(p.parse("queue 0").isError());
		assertEquals("Command type: queue\nParameters:\nID: 1\n", p.parse("queue 1").toString());
		assertEquals("Command type: queue\nParameters:\nID: 2\n", p.parse("queue 2").toString());
		
		// 2 parameters
		
		// Valid ID, invalid position
		assertTrue(p.parse("queue 5 position").isError());
		
		// Invalid ID, valid position
		assertTrue(p.parse("queue -1 2").isError());
		
		// Invalid ID, invalid position
		assertTrue(p.parse("queue up please").isError());
		
		// Position not a number
		assertTrue(p.parse("queue 1 abc").isError());
		
		// Position < 1
		assertTrue(p.parse("queue 1 -5").isError());
		
		// Position >= 1
		assertEquals("Command type: queue\nParameters:\nID: 1\nPosition: 5\n",
					 p.parse("queue 1 5").toString());
		
		// Boundary
		assertTrue(p.parse("queue 0 -1").isError());
		assertEquals("Command type: queue\nParameters:\nID: 1\nPosition: 1\n",
					 p.parse("queue 1 1").toString());
		assertEquals("Command type: queue\nParameters:\nID: 2\nPosition: 2\n",
				 	 p.parse("queue 2 2").toString());
		
		// > 2 parameters
		assertTrue(p.parse("queue 1 2 3").isError());
	}
	
	@Test
	public void testRedo() {
		// 0 parameters
		assertEquals("Command type: redo\nParameters:\n", p.parse("redo").toString());

		// Has parameters
		assertTrue(p.parse("redo 1").isError());
	}
	
	@Test
	public void testSave() {
		// 0 parameters
		assertEquals("Command type: save\nParameters:\n", p.parse("save").toString());

		// Has parameters
		assertTrue(p.parse("save me").isError());
	}
	
	@Test
	public void testSaveto() {
		// 0 parameters
		assertTrue(p.parse("saveto").isError());

		// Has parameters
		assertEquals("Command type: saveto\nParameters:\nPath: myfile.txt\n",
					 p.parse("saveto myfile.txt").toString());		
		assertEquals("Command type: saveto\nParameters:\nPath: C:/Documents/myfile.txt\n",
					 p.parse("saveto C:/Documents/myfile.txt").toString());
	}

	@Test
	public void testSetlimit() {
		// 0 parameters
		assertTrue(p.parse("setlimit").isError());

		// 1 parameter

		// ID not a number
		assertTrue(p.parse("setlimit abc").isError());

		// ID < 0
		assertTrue(p.parse("setlimit -1").isError());

		// ID >= 0
		assertEquals("Command type: delete\nParameters:\nID: 5\n", p.parse("delete 5").toString());

		// Boundary
		assertTrue(p.parse("delete 0").isError());
		assertEquals("Command type: delete\nParameters:\nID: 1\n", p.parse("delete 1").toString());
		assertEquals("Command type: delete\nParameters:\nID: 2\n", p.parse("delete 2").toString());

		// > 1 parameter
		assertTrue(p.parse("delete 1 1").isError());
	}
	
	@Test
	public void testSetdefault() {
		//TODO
		// Not yet implemented
	}
	
	@Test
	public void testUndo() {
		// 0 parameters
		assertEquals("Command type: undo\nParameters:\n", p.parse("undo").toString());

		// Has parameters
		assertTrue(p.parse("undo 1").isError());
	}
	
	@Test
	public void testInvalidCommand() {
		// Invalid command without parameters
		assertTrue(p.parse("notacommand").isError());
		assertTrue(p.parse("addd").isError());
		
		// Invalid command with parameters
		assertTrue(p.parse("not a command").isError());
	}
}
```
###### \src\tucklife\parser\ProtoTask.java
``` java
package tucklife.parser;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public class ProtoTask {
	
	private String command;
	private String taskDesc;
	private String location;
	private String category;
	private String additional;
	private String searchKey;
	private String sortCrit;
	private String demoCommand;
	private String path;
	private String changeMessage;
	
	private int priority = -1;
	private int id = -1;
	private int limit = -1;
	private int position = -1;
	
	private boolean hasSortOrder = false;
	private boolean isAscending = false;
	
	private Calendar startDate;
	private Calendar startTime;
	private Calendar endDate;
	private Calendar endTime;
	private SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
	
	private boolean isError;
	private String errorMessage;
	
	/*****************************
	 * Constructor for ProtoTask *
	 *****************************/
	public ProtoTask(String commandType) {
		if (commandType.equalsIgnoreCase("error")) {
			isError = true;
		} else {
			isError = false;
			command = commandType;
		}
	}
	
	/**************************
	 * Getters for parameters *
	 **************************/
	public String getCommand() {
		return command;
	}
	
	public String getTaskDesc() {
		return taskDesc;
	}
	
	public String getLocation() {
		return location;
	}
	
	public String getCategory() {
		return category;
	}
	
	public String getAdditional() {
		return additional;
	}
	
	public String getSearchKey() {
		return searchKey;
	}
	
	public String getSortCrit() {
		return sortCrit;
	}
	
	public String getDemoCommand() {
		return demoCommand;
	}
	
	public String getPath() {
		return path;
	}
	
	public String getChangeMessage() {
		return changeMessage;
	}
	
	public int getPriority() {
		return priority;
	}
	
	public int getId() {
		return id;
	}
	
	public int getLimit() {
		return limit;
	}
	
	public int getPosition() {
		return position;
	}
	
	public boolean getHasSortOrder() {
		return hasSortOrder;
	}
	
	public boolean getIsAscending() {
		return isAscending;
	}
	
	public Calendar getStartDate() {
		return startDate;
	}
	
	public Calendar getEndDate() {
		return endDate;
	}
	
	public Calendar getStartTime() {
		return startTime;
	}
	
	public Calendar getEndTime() {
		return endTime;
	}
	
	public boolean isError() {
		return isError;
	}
	
	public String getErrorMessage() {
		return errorMessage;
	}
	
	/**************************
	 * Setters for parameters *
	 **************************/
	public void setTaskDesc(String td) {
		taskDesc = td;
	}
	
	public void setLocation(String l) {
		location = l;
	}
	
	public void setCategory(String c) {
		category = c;
	}
	
	public void setAdditional(String a) {
		additional = a;
	}
	
	public void setSearchKey(String sk) {
		searchKey = sk;
	}
	
	public void setSortCrit(String sc) {
		sortCrit = sc;
	}
	
	public void setDemoCommand(String dc) {
		demoCommand = dc;
	}
	
	public void setPath(String p) {
		path = p;
	}
	
	public void setChangeMessage(String cm) {
		changeMessage = cm;
	}

	public void setPriority(int p) {
		priority = p;
	}
	
	public void setId(int i) {
		id = i;
	}
	
	public void setLimit(int l) {
		limit = l;
	}
	
	public void setPosition(int p) {
		position = p;
	}
	
	public void setHasSortOrder(boolean s) {
		hasSortOrder = s;
	}
	
	public void setIsAscending(boolean a) {
		isAscending = a;
	}
	
	public void setStartDate(Calendar sd) {
		startDate = sd;
	}
	
	public void setStartTime(Calendar st) {
		startTime = st;
	}
	
	public void setEndDate(Calendar ed) {
		endDate = ed;
	}
	
	public void setEndTime(Calendar et) {
		endTime = et;
	}
	
	public void setErrorMessage(String em) {
		isError = true;
		errorMessage = em;
	}
	
	/*****************
	 * Other methods *
	 *****************/
	public String toString() {
		if (isError) {
			return "Error: " + errorMessage + "\n";
		} else {
			String toDisplay = "Command type: " + command + "\n";
			toDisplay += "Parameters:\n";

			if (taskDesc != null) {
				toDisplay += "Task description: " + taskDesc + "\n";
			}

			if (location != null) {
				toDisplay += "Location: " + location + "\n";
			}

			if (category != null) {
				toDisplay += "Category: " + category + "\n";
			}

			if (additional != null) {
				toDisplay += "Additional information: " + additional + "\n";
			}

			if (searchKey != null) {
				toDisplay += "Search keyword: " + searchKey + "\n";
			}

			if (sortCrit != null) {
				toDisplay += "Sort criteria: " + sortCrit + "\n";
			}

			if (demoCommand != null) {
				toDisplay += "Demo command: " + demoCommand + "\n";
			}

			if (path != null) {
				toDisplay += "Path: " + path + "\n";
			}
			
			if (changeMessage != null) {
				toDisplay += "Change message: " + changeMessage + "\n";
			}

			if (priority != -1) {
				toDisplay += "Priority: " + priority + "\n";
			}

			if (id != -1) {
				toDisplay += "ID: " + id + "\n";
			}
			
			if (limit != -1) {
				toDisplay += "Limit: " + limit + "\n";
			}
			
			if (position != -1) {
				toDisplay += "Position: " + position + "\n";
			}
			
			if (hasSortOrder) {
				if (isAscending) {
					toDisplay += "Sort order: ascending\n";
				} else {
					toDisplay += "Sort order: descending\n";
				}
			}

			if (startDate != null) {
				toDisplay += "Start date: " + sdf.format(startDate.getTime()) + "\n";
			}
			
			if (startTime != null) {
				toDisplay += "Start time: " + sdf.format(startTime.getTime()) + "\n";
			}

			if (endDate != null) {
				toDisplay += "End date: " + sdf.format(endDate.getTime()) + "\n";
			}
			
			if (endTime != null) {
				toDisplay += "End time: " + sdf.format(endTime.getTime()) + "\n";
			}


			return toDisplay;
		}
	}
}
```
###### \src\tucklife\storage\CommandStorage.java
``` java
package tucklife.storage;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Hashtable;

public class CommandStorage {
	
	private static final String FILENAME_COMMANDS = "commands.txt";
	
	private Hashtable<String, String> commandTable;
	
	private String[] commandTypes = { "add", "change", "complete", "delete", "demo", "display", "displaydone",
									  "edit", "exit", "help", "queue", "redo",
									  "save", "saveto", "setlimit", "setdefault", "undo" };
	
	public CommandStorage() {
		commandTable = new Hashtable<String, String>();
	}
	
	public boolean loadCommands() {
		FileInputStream fis;
		InputStreamReader isr;
		BufferedReader br;
		
		try {
			// Create new commands file if it does not exist
			if (!Files.exists(Paths.get(FILENAME_COMMANDS))) {
				Files.createFile(Paths.get(FILENAME_COMMANDS));
			}
			
			fis = new FileInputStream(FILENAME_COMMANDS);
			isr = new InputStreamReader(fis);
			br = new BufferedReader(isr);
			
			String[] nextLine;
			
			while(br.ready()){
				nextLine = br.readLine().split(",");
				commandTable.put(nextLine[0], nextLine[1]);
			}
			
			br.close();
			isr.close();
			fis.close();
			
		} catch(IOException ioe){
			ioe.printStackTrace();
			return false;
		}
		
		return true;
	}
	
	public boolean saveCommands(Hashtable<String, String> ht) {
		try {
			FileOutputStream fos = new FileOutputStream(FILENAME_COMMANDS);
			BufferedOutputStream bos = new BufferedOutputStream(fos);
			
			// Write custom commands to file
			for (String key:commandTypes) {
				if (ht.containsKey(key)) {
					String newEntry = key + "," + ht.get(key) + "\n";
					bos.write(newEntry.getBytes());
				}
			}
			
			bos.close();
			fos.close();
		
		// Should not happen under any circumstance
		} catch(FileNotFoundException fnfe){
			return false;
			
		} catch(IOException ioe){
			return false;
		}
		
		return true;
	}
	
	public Hashtable<String, String> getCommands() {
		return commandTable;
	}
}
```
