# A0127835Y
###### \src\tucklife\parser\DateParser.java
``` java
package tucklife.parser;

import java.util.Calendar;
import java.util.Date;
import java.text.ParseException;
import java.text.SimpleDateFormat;

/*
 * Supported date formats:
 * - Text dates:
 *   - Both short month names (jan, feb) and full month names (january, february)
 *   - ddmmm or ddmmmyy or ddmmmyyyy (15jan)
 *   - dd mmm or dd mmm yy or dd mmm yyyy (15 jan)
 *   - dd-mmm or dd-mmm-yy or dd-mmm-yyyy (15-jan)
 *   
 * - Number dates:
 *   - dd/mm or dd/mm/yy or dd/mm/yyyy (15/1)
 *   - dd.mm or dd.mm.yy or dd.mm.yyyy (15.1)
 *   - dd-mm or dd-mm-yy or dd-mm-yyyy (15-1)
 *   
 * - Others
 *   - today
 *   - tmr or tomorrow
 *   - day of week (mon, monday, next mon)
 *
 * Supported time formats:
 * - 12-hour
 * 	- hh.mm am/pm
 * 	- hh:mm am/pm
 * 	- hh am/pm
 * 
 * - 24-hour
 *  - hh.mm
 *  - hh:mm
 *  - hhmm
 * 
 * Notes:
 * - If only time is specified and has passed for today,
 *   returned date will be for tomorrow at specified time.
 *   
 * - If only date is specified, default time is 11:59pm.
 * 
 * - If date specified is without year, and has passed for current year,
 *   return date will be for next year.
 *   
 * - If 29/2 is entered, return date is for next available year.
 *   If it is not a leap year, return 28/2.
 *   
 * - Short form for September is 'Sep' not 'Sept'
 */

public class DateParser {
	
	private Calendar calendar;
	
	// Indicates whether the year is included in user-entered date
	private boolean hasYear = false;
	
	// Indicates whether user-entered time is in 12-hour format
	private boolean is12Hour = false;
	
	// Hour and minutes parsed from user-entered time
	private int timeHour;
	private int timeMin;
	
	/* ***************
	 * Date formats *
	 ****************/
	
	// Format: dd/mm/yy or dd/mm/yyyy
	private static final String DATE_DMY_SLASH = "[0-3]?\\d/[01]?\\d/\\d{2}(\\d{2})?";
	
	// Format: dd.mm.yy or dd.mm.yyyy
	private static final String DATE_DMY_DOT = "[0-3]?\\d\\.[01]?\\d\\.\\d{2}(\\d{2})?";
	
	// Format: dd-mm-yy or dd-mm-yyyy
	private static final String DATE_DMY_DASH = "[0-3]?\\d-[01]?\\d-\\d{2}(\\d{2})?";
	
	// Format: dd/mm
	private static final String DATE_DM_SLASH = "[0-3]?\\d/[01]?\\d";
	
	// Format: dd.mm
	private static final String DATE_DM_DOT = "[0-3]?\\d\\.[01]?\\d";
	
	// Format: dd-mm
	private static final String DATE_DM_DASH = "[0-3]?\\d-[01]?\\d";
	
	// Format: ddmmmyy (short month)
	private static final String DATE_SHORT_DMY = "[0-3]?\\d[a-zA-Z]{3}\\d{2}(\\d{2})?";
	
	// Format: dd mmm yy (short month)
	private static final String DATE_SHORT_DMY_SPACE = "[0-3]?\\d\\s[a-zA-Z]{3}\\s\\d{2}(\\d{2})?";
	
	// Format: dd-mmm (short month)
	private static final String DATE_SHORT_DMY_DASH = "[0-3]?\\d-[a-zA-Z]{3}-\\d{2}(\\d{2})?";
	
	// Format: ddmmm (short month)
	private static final String DATE_SHORT_DM = "[0-3]?\\d[a-zA-Z]{3}";
	
	// Format: dd mmm (short month)
	private static final String DATE_SHORT_DM_SPACE = "[0-3]?\\d\\s[a-zA-Z]{3}";
	
	// Format: dd-mmm (short month)
	private static final String DATE_SHORT_DM_DASH = "[0-3]?\\d-[a-zA-Z]{3}";
	
	// Format: ddmmmm (full month)
	private static final String DATE_FULL_DMY = "[0-3]?\\d[a-zA-Z]{4,9}\\d{2}(\\d{2})?";

	// Format: dd mmmm (full month)
	private static final String DATE_FULL_DMY_SPACE = "[0-3]?\\d\\s[a-zA-Z]{4,9}\\s\\d{2}(\\d{2})?";

	// Format: dd-mmmm (full month)
	private static final String DATE_FULL_DMY_DASH = "[0-3]?\\d-[a-zA-Z]{4,9}-\\d{2}(\\d{2})?";

	// Format: ddmmmm (full month)
	private static final String DATE_FULL_DM = "[0-3]?\\d[a-zA-Z]{4,9}";
	
	// Format: dd mmmm (full month)
	private static final String DATE_FULL_DM_SPACE = "[0-3]?\\d\\s[a-zA-Z]{4,9}";
	
	// Format: dd-mmmm (full month)
	private static final String DATE_FULL_DM_DASH = "[0-3]?\\d-[a-zA-Z]{4,9}";
	
	// Format: Short day name
	private static final String DAY_SHORT = "(next\\s)?[a-zA-Z]{3,5}";
	
	// Format: Full day name
	private static final String DAY_FULL = "(next\\s)?[a-zA-Z]{6,9}";
	
	/* *************
	 * Time formats *
	 ****************/
	
	// Format: hh.mm am/pm (12-hour)
	private static final String TIME_12HM_DOT = "[01]?\\d\\.[0-5]\\d\\s?[aApP][mM]";
	
	// Format: hh:mm am/pm (12-hour)
	private static final String TIME_12HM_COLON = "[01]?\\d:[0-5]\\d\\s?[aApP][mM]";
	
	// Format: hh am/pm (12-hour)
	private static final String TIME_12H = "[01]?\\d\\s?[aApP][mM]";
	
	// Format: hh.mm (24-hour)
	private static final String TIME_24H_DOT = "[0-2]?\\d\\.[0-5]\\d";
	
	// Format: hh:mm (24-hour)
	private static final String TIME_24H_COLON = "[0-2]?\\d:[0-5]\\d";
	
	// Format hhmm (24-hour)
	private static final String TIME_24H = "[0-2]\\d[0-5]\\d";
	
	public DateParser() {
		reset();
	}
	
	// Reset the calendar to current date and time
	public void reset() {
		calendar = Calendar.getInstance();
		timeHour = calendar.get(Calendar.HOUR_OF_DAY);
		timeMin = calendar.get(Calendar.MINUTE);
	}
	
	// Parse date
	public Calendar parseDate(String rawDate) throws InvalidDateException {
		SimpleDateFormat sdf;
		reset();
		
		if (rawDate.equalsIgnoreCase("today")) {
			// Today
			hasYear = true;
			return calendar;
			
		} else if (rawDate.equalsIgnoreCase("tomorrow") || rawDate.equalsIgnoreCase("tmr")) {
			// Tomorrow
			hasYear = true;
			calendar.add(Calendar.DATE, 1);
			return calendar;
			
		} else if (rawDate.matches(DAY_SHORT) || rawDate.matches(DAY_FULL)) {
			// Day of week
			
			hasYear = true;
			String[] d = rawDate.split(" ");
			String dayOfWeek;
			boolean isNextWeek = false;
			
			if (d.length == 1) {
				dayOfWeek = rawDate;
			} else if (d.length == 2 && d[0].equalsIgnoreCase("next")) {
				dayOfWeek = d[1].toLowerCase();
				isNextWeek = true;
			} else {
				throw new InvalidDateException("invalid date");
			}

			int taskDay = -1;
			int today = calendar.get(Calendar.DAY_OF_WEEK);

			if (dayOfWeek.equals("mon") || dayOfWeek.equals("monday")) {
				taskDay = Calendar.MONDAY;
			} else if (dayOfWeek.equals("tue") || dayOfWeek.equals("tues")
					   || dayOfWeek.equals("tuesday")) {
				taskDay = Calendar.TUESDAY;
			} else if (dayOfWeek.equals("wed") || dayOfWeek.equals("wednesday")) {
				taskDay = Calendar.WEDNESDAY;
			} else if (dayOfWeek.equals("thu") || dayOfWeek.equals("thur")
					   || dayOfWeek.equals("thurs") || dayOfWeek.equals("thursday")) {
				taskDay = Calendar.THURSDAY;
			} else if (dayOfWeek.equals("fri") || dayOfWeek.equals("friday")) {
				taskDay = Calendar.FRIDAY;
			} else if (dayOfWeek.equals("sat") || dayOfWeek.equals("saturday")) {
				taskDay = Calendar.SATURDAY;
			} else if (dayOfWeek.equals("sun") || dayOfWeek.equals("sunday")) {
				taskDay = Calendar.SUNDAY;
			}

			if (taskDay == -1) {
				throw new InvalidDateException("invalid date");
			} else {
				if (today > taskDay || isNextWeek) {
					calendar.add(Calendar.DATE, 7);
				}

				calendar.set(Calendar.DAY_OF_WEEK, taskDay);

				return calendar;
			}
			
		} else {
			// Other date formats
			
			/* ***********************
			 * Variations of dd mm yy *
			 *************************/
			if (rawDate.matches(DATE_DMY_SLASH)) {
				sdf = new SimpleDateFormat("dd/M/yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_DMY_DOT)) {
				sdf = new SimpleDateFormat("dd.M.yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_DMY_DASH)) {
				sdf = new SimpleDateFormat("dd-M-yy");
				hasYear = true;
			
			/* ********************
			 * Variations of dd mm *
			 **********************/ 
			} else if (rawDate.matches(DATE_DM_SLASH)) {
				rawDate += "/" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd/M/yy");
				hasYear = false;
			} else if (rawDate.matches(DATE_DM_DOT)) {
				rawDate += "." + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd.M.yy");
				hasYear = false;
			} else if (rawDate.matches(DATE_DM_DASH)) {
				rawDate += "-" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd-M-yy");
				hasYear = false;
			
			/* ***************************************
			 * Variations of dd mmm yy (short month) *
			 *****************************************/
			} else if (rawDate.matches(DATE_SHORT_DMY)) {
				sdf = new SimpleDateFormat("ddMMMyy");
				hasYear = true;
			} else if (rawDate.matches(DATE_SHORT_DMY_SPACE)) {
				sdf = new SimpleDateFormat("dd MMM yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_SHORT_DMY_DASH)) {
				sdf = new SimpleDateFormat("dd-MMM-yy");
				hasYear = true;
			
			/* ************************************
			 * Variations of dd mmm (short month) *
			 **************************************/
			} else if (rawDate.matches(DATE_SHORT_DM)) {
				rawDate += calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("ddMMMyy");
				hasYear = false;
			} else if (rawDate.matches(DATE_SHORT_DM_SPACE)) {
				rawDate += " " + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd MMM yy");
				hasYear = false;
			} else if (rawDate.matches(DATE_SHORT_DM_DASH)) {
				rawDate += "-" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd-MMM-yy");
				hasYear = false;
				
			/* ***************************************
			 * Variations of dd mmmm yy (long month) *
			 *****************************************/
			} else if (rawDate.matches(DATE_FULL_DMY)) {
				sdf = new SimpleDateFormat("ddMMMMyy");
				hasYear = true;
			} else if (rawDate.matches(DATE_FULL_DMY_SPACE)) {
				sdf = new SimpleDateFormat("dd MMMM yy");
				hasYear = true;
			} else if (rawDate.matches(DATE_FULL_DMY_DASH)) {
				sdf = new SimpleDateFormat("dd-MMMM-yy");
				hasYear = true;
				
			/* ************************************
			 * Variations of dd mmmm (long month) *
			 **************************************/
			} else if (rawDate.matches(DATE_FULL_DM)) {
				rawDate += calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("ddMMMMyy");
				hasYear = false;
			} else if (rawDate.matches(DATE_FULL_DM_SPACE)) {
				rawDate += " " + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd MMMM yy");
				hasYear = false;
			} else if (rawDate.matches(DATE_FULL_DM_DASH)) {
				rawDate += "-" + calendar.get(Calendar.YEAR);
				sdf = new SimpleDateFormat("dd-MMMM-yy");
				hasYear = false;
				
			// Unrecognised date
			} else {
				throw new InvalidDateException("invalid date");
			}

			sdf.setLenient(false);
			
			try {
				Date date = sdf.parse(rawDate);
				calendar.setTime(date);
				
				if (isPastDate()) {
					if (hasYear) {
						throw new InvalidDateException("date has passed. You can't travel back in time!");
					} else {
						calendar.add(Calendar.YEAR, 1);
					}
				}
				
				return calendar;
			} catch (ParseException e) {
				throw new InvalidDateException("invalid date");
			}				
		}
	}
	
	// Parse time
	public Calendar parseTime(String rawTime) throws InvalidDateException {
		reset();
		is12Hour = false;
		
		/* ****************************
		 * Variations of 12-hour time *
		 ******************************/
		if (rawTime.matches(TIME_12HM_DOT)) {
			int dotPos = rawTime.indexOf(".");
			timeHour = Integer.parseInt(rawTime.substring(0, dotPos));
			timeMin = Integer.parseInt(rawTime.substring(dotPos + 1, dotPos + 3));
			is12Hour = true;
		} else if (rawTime.matches(TIME_12HM_COLON)) {
			int colonPos = rawTime.indexOf(":");
			timeHour = Integer.parseInt(rawTime.substring(0, colonPos));
			timeMin = Integer.parseInt(rawTime.substring(colonPos + 1, colonPos + 3));
			is12Hour = true;
		} else if (rawTime.matches(TIME_12H)) {
			timeHour = Integer.parseInt(rawTime.split("\\s?[aApP]")[0]);
			timeMin = 0;
			is12Hour = true;
			
		/* ****************************
		 * Variations of 24-hour time *
		 ******************************/
		} else if (rawTime.matches(TIME_24H_DOT)) {
			int dotPos = rawTime.indexOf(".");
			timeHour = Integer.parseInt(rawTime.substring(0, dotPos));
			timeMin = Integer.parseInt(rawTime.substring(dotPos + 1, dotPos + 3));
		} else if (rawTime.matches(TIME_24H_COLON)) {
			int colonPos = rawTime.indexOf(":");
			timeHour = Integer.parseInt(rawTime.substring(0, colonPos));
			timeMin = Integer.parseInt(rawTime.substring(colonPos + 1, colonPos + 3));
		} else if (rawTime.matches(TIME_24H)) {
			timeHour = Integer.parseInt(rawTime.substring(0, 2));
			timeMin = Integer.parseInt(rawTime.substring(2, rawTime.length()));
			
		// Unrecognised time
		} else {
			throw new InvalidDateException("invalid time");
		}
		
		// Conversion to 24-hour time
		if (is12Hour) {
			// Check if time is valid
			if (timeHour == 0) {
				throw new InvalidDateException("invalid time");
			}
			
			if (isPm(rawTime)) {
				if (timeHour != 12) {
					timeHour += 12;
				}
			} else {
				if (timeHour == 12) {
					timeHour = 0;
				}
			}
		}
		
		// Check if time is valid
		if (timeHour > 23) {
			throw new InvalidDateException("invalid time");
		}
		
		calendar.set(Calendar.HOUR_OF_DAY, timeHour);
		calendar.set(Calendar.MINUTE, timeMin);
		return calendar;
	}
	
	// Check if date entered has passed for current year
	private boolean isPastDate() {
		Calendar c = Calendar.getInstance();
		c.add(Calendar.DATE, -1);
		return calendar.before(c);
	}

	
	// Check if time of day is am or pm
	private boolean isPm(String time) {
		String timeOfDay = time.substring(time.length() - 2, time.length());
		return timeOfDay.equalsIgnoreCase("pm");
	}
	
	// Check if date is over
	public boolean isDateOver(Calendar c) {
		Calendar curr = Calendar.getInstance();
		return c.before(curr);
	}
	
	// Combines date and time into a single Calendar
	public Calendar combineDateTime(Calendar date, Calendar time) {
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.YEAR, date.get(Calendar.YEAR));
		c.set(Calendar.MONTH, date.get(Calendar.MONTH));
		c.set(Calendar.DATE, date.get(Calendar.DATE));
		
		c.set(Calendar.HOUR_OF_DAY, time.get(Calendar.HOUR_OF_DAY));
		c.set(Calendar.MINUTE, time.get(Calendar.MINUTE));
		
		return c;
	}
	
	// Return default start time
	public Calendar getDefaultStartTime() {
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		
		return c;
	}
	
	// Return default end time
	public Calendar getDefaultEndTime() {
		Calendar c = Calendar.getInstance();
		
		c.set(Calendar.HOUR_OF_DAY, 23);
		c.set(Calendar.MINUTE, 59);
		
		return c;
	}
	
	// Return default date
	public Calendar getDefaultDate() {
		return Calendar.getInstance();
	}
	
	// Return the next day from date in c
	public Calendar getNextDay(Calendar c) {
		Calendar next = c;
		next.add(Calendar.DATE, 1);
		
		return next;
	}
	
	// Return next year from date in c
	public Calendar getNextYear(Calendar c) {
		Calendar next = c;
		next.add(Calendar.YEAR, 1);
		
		return next;
	}
	
	// Returns the date that is used to signify deleting it from task
	public Calendar getRemovalDate() {
		Calendar removalDate = Calendar.getInstance();
		removalDate.set(Calendar.YEAR, 2000);
		
		return removalDate;
	}
	
	// Check if year is entered by user
	// Only use right after parsing date, otherwise it won't work
	public boolean hasYear() {
		return hasYear;
	}
}
```
###### \src\tucklife\parser\InvalidDateException.java
``` java
package tucklife.parser;

public class InvalidDateException extends Exception {
	
	public InvalidDateException(String errorMsg) {
		super(errorMsg);
	}
}
```
###### \src\tucklife\parser\InvalidParamException.java
``` java
package tucklife.parser;

public class InvalidParamException extends Exception {
	
	public InvalidParamException(String errorMsg) {
		super(errorMsg);
	}
}
```
###### \src\tucklife\parser\Parser.java
``` java
package tucklife.parser;

import java.util.Calendar;
import java.util.Hashtable;
import java.util.Enumeration;

public class Parser {
	
	private String paramSymbols = "-+$#!&@";
	private ProtoTask pt;
	private DateParser dp;
	private Hashtable<String, String> commandTable;
	
	private enum CommandType {
		ADD, CHANGE, COMPLETE, DELETE, DEMO, DISPLAY, DISPLAYDONE, EDIT, ERROR, EXIT,
		HELP, QUEUE, REDO, SAVE, SAVETO, SETLIMIT, UNCOMPLETE, UNDO;
	}
	
	// Indicator for extractParameter to show that parameter is to be removed
	private final String EMPTY = " ";
	
	// Indicator for ProtoTask to tell Storage that parameter is to be removed
	private final String TO_REMOVE = "";
	
	/* ****************
	 * Error messages *
	 ******************/
	
	private final String ERROR_INVALID_PARAMS = "Incorrect number of parameters";
	private final String ERROR_INVALID_COMMAND = "'%1$s' is not a valid command";
	private final String ERROR_INVALID_SORT_PARAMS = "invalid sort parameters.\nValid parameters: "
													 + paramSymbols.substring(1);
	private final String ERROR_INVALID_PRIORITY = "invalid priority";
	private final String ERROR_INVALID_DATE = "invalid date";
	private final String ERROR_INVALID_TIME = "invalid time";
	private final String ERROR_INVALID_EVENT_FORMAT = "invalid event format";
	
	private final String ERROR_ID_NOT_POSITIVE = "id '%1$s' must be positive";
	private final String ERROR_POSITION_NOT_POSITIVE = "position '%1$s' must be positive";
	private final String ERROR_LIMIT_NOT_NON_NEGATIVE = "limit '%1$s' must be non-negative";
	private final String ERROR_RESERVED_ALIAS = "'%1$s' is a reserved command alias / type for the command '%2$s'";
	private final String ERROR_DATE_OVER = "date has passed.\nYou can't travel back in time!";
	private final String ERROR_START_AFTER_END = "start date is after end date.\nYou can't travel back in time!";
	private final String ERROR_ODD_INVERTED_COMMAS = "inverted commas don't match.\nMake sure to add closing inverted commas.";
	
	private final String ERROR_PARAMS_NONE = "Format: %1$s";
	private final String ERROR_PARAMS_ID = "Format: %1$s <id>";
	private final String ERROR_PARAMS_ADD = "Format: add <task description> (optional: $<date> "
										  + "+<time> #<category> !<priority> @<location> &<additional>)";
	private final String ERROR_PARAMS_EDIT = "Format: edit <id> (at least 1 of the following: <task description> "
										   + "$<date> +<time> #<category> !<priority> @<location> &<additional>)";
	private final String ERROR_PARAMS_QUEUE = "Format: queue <id> <pos>";
	private final String ERROR_PARAMS_DEMO = "Format: demo <command>";
	private final String ERROR_PARAMS_LIMIT = "Format: setlimit <limit>";
	private final String ERROR_PARAMS_SAVETO = "Format: saveto <file path>";
	private final String ERROR_PARAMS_CHANGE = "Format: change <old command> <new command>";
	
	/* ****************
	 * Other messages *
	 ******************/
	
	private final String MESSAGE_CHANGED_ALIAS = "'%1$s' has been changed to '%2$s'!";
	private final String MESSAGE_SAME_ALIAS = "'%1$s' is the same as '%2$s'! No change occurred.";

	public Parser() {
		dp = new DateParser();
	}
	
	/**
	 * This method takes in a user input command and parses it into a ProtoTask object
	 * 
	 * @param command User input command.
	 * @return ProtoTask with the relevant parameters.
	 */
	public ProtoTask parse(String command) {
		String commandAlias = getFirstWord(command.trim()).toLowerCase();
		String commandArgument = getRemainingArgument(command.trim());
		CommandType type = convertAliasToDefault(commandAlias);
		
		if (type == CommandType.ERROR) {
			// Unrecognized command type
			createErrorTask(String.format(ERROR_INVALID_COMMAND, commandAlias));
		} else {
			try {
				// Parse command parameters
				pt = new ProtoTask(commandTypeToString(type));
				parseParameters(type, commandArgument);
			} catch (InvalidParamException ipe) {
				// Invalid command
				createErrorTask(ipe.getMessage());
			}
		}
		
		return pt;
	}
	
	/**
	 * This method returns the Hashtable which stores all the custom command mappings.
	 * 
	 * @return Custom command mappings.
	 */
	public Hashtable<String, String> getCommands() {
		return commandTable;
	}
	
	/**
	 * This method loads the custom command mappings from a Hashtable.
	 * 
	 * @param ht Custom command mappings.
	 */
	public void loadCommands(Hashtable<String, String> ht) {
		commandTable = ht;
	}
	
	/**
	 * This method takes in a String representing a command type, and returns
	 * the type of command as a CommandType enum constant.
	 * 
	 * @param type Command type.
	 * @return CommandType enum constant corresponding to type of command,
	 * 		   CommandType.ERROR if no command type found.
	 */
	private CommandType getCommandType(String type) {
		if (type.equals("add")) {
			return CommandType.ADD;
		} else if (type.equals("change")) {
			return CommandType.CHANGE;
		} else if (type.equals("complete")) {
			return CommandType.COMPLETE;
		} else if (type.equals("delete")) {
			return CommandType.DELETE;
		} else if (type.equals("demo")) {
			return CommandType.DEMO;
		} else if (type.equals("display")) {
			return CommandType.DISPLAY;
		} else if (type.equals("displaydone")) {
			return CommandType.DISPLAYDONE;
		} else if (type.equals("edit")) {
			return CommandType.EDIT;
		} else if (type.equals("exit")) {
			return CommandType.EXIT;
		} else if (type.equals("help")) {
			return CommandType.HELP;
		} else if (type.equals("queue")) {
			return CommandType.QUEUE;
		} else if (type.equals("redo")) {
			return CommandType.REDO;
		} else if (type.equals("save")) {
			return CommandType.SAVE;
		} else if (type.equals("saveto")) {
			return CommandType.SAVETO;
		} else if (type.equals("setlimit")) {
			return CommandType.SETLIMIT;
		} else if (type.equals("uncomplete")) {
			return CommandType.UNCOMPLETE;
		} else if (type.equals("undo")) {
			return CommandType.UNDO;
		} else {
			// Invalid command type
			return CommandType.ERROR;
		}
	}
	
	/**
	 * This method parses the command parameters based on the command type and
	 * adds the parameters into a ProtoTask object. If any of the parameters are
	 * invalid, it creates an error ProtoTask.
	 * 
	 * @param commandType CommandType enum constant for the type of command.
	 * @param commandArg String of all the parameters for the command.
	 */
	private void parseParameters(CommandType commandType, String commandArg)
			throws InvalidParamException {
		switch (commandType) {
			case ADD :
				parseAdd(commandArg);
				break;
				
			case CHANGE :
				parseChange(commandArg);
				break;
				
			case COMPLETE :
				parseComplete(commandArg);
				break;
				
			case DELETE :
				parseDelete(commandArg);
				break;
				
			case DEMO :
				parseDemo(commandArg);
				break;
				
			case DISPLAY :
				parseDisplay(commandArg);
				break;
				
			case DISPLAYDONE :
				parseDisplay(commandArg);
				break;
				
			case EDIT :
				parseEdit(commandArg);
				break;
				
			case EXIT :
				parseExit(commandArg);
				break;
				
			case HELP :
				parseHelp(commandArg);
				break;
				
			case QUEUE :
				parseQueue(commandArg);
				break;
				
			case REDO :
				parseRedo(commandArg);
				break;
				
			case SAVE :
				parseSave(commandArg);
				break;
				
			case SAVETO :
				parseSaveto(commandArg);
				break;
				
			case SETLIMIT :
				parseSetlimit(commandArg);
				break;
				
			case UNCOMPLETE :
				parseUncomplete(commandArg);
				break;
				
			case UNDO :
				parseUndo(commandArg);
				break;
				
			default :
				// Should not happen
				createErrorTask("invalid command entered");
				break;
		}
	}
	
	// Add
	private void parseAdd(String commandArg) throws InvalidParamException {
		if (commandArg.isEmpty()) {
			// No parameter given
			createErrorTask(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_ADD);
		} else {
			// Parameter is given
			parseTaskCommands(CommandType.ADD, commandArg);
		}
	}
	
	// Change
	private void parseChange(String commandArg) throws InvalidParamException {
		String[] commands = commandArg.split(" ");
		
		if (commands.length != 2) {
			// Invalid number of parameters
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_CHANGE);
		} else {
			String oldCommand = commands[0];
			String newCommand = commands[1];
			CommandType oldType = convertAliasToDefault(oldCommand);
			CommandType newType = convertAliasToDefault(newCommand);
			
			if (oldType != CommandType.ERROR) {
				// Old command name is valid
				if (newType == oldType) {
					// New command has already been set
					pt.setChangeMessage(String.format(MESSAGE_SAME_ALIAS, oldCommand, newCommand));
				} else if (newType != CommandType.ERROR) {
					// New command is used for another command
					throw new InvalidParamException(String.format(ERROR_RESERVED_ALIAS, newCommand,
																  commandTypeToString(newType)));
				} else {
					// New command is unused
					commandTable.put(commandTypeToString(oldType), newCommand);
					pt.setChangeMessage(String.format(MESSAGE_CHANGED_ALIAS, oldCommand, newCommand));
				}
			} else {
				// Old command name is invalid
				throw new InvalidParamException(String.format(ERROR_INVALID_COMMAND, oldCommand));
			}
		}
	}
	
	// Complete
	private void parseComplete(String commandArg) throws InvalidParamException {
		parseCommandWithId(CommandType.COMPLETE, commandArg);
	}
	
	// Delete
	private void parseDelete(String commandArg) throws InvalidParamException {
		parseCommandWithId(CommandType.DELETE, commandArg);
	}
	
	// Demo
	private void parseDemo(String commandArg) throws InvalidParamException {
		if (commandArg.isEmpty()) {
			// No parameter given
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_DEMO);
		} else if (convertAliasToDefault(commandArg) != CommandType.ERROR) {
			// Command to demo is valid command
			pt.setDemoCommand(commandArg);
		} else {
			// Command to demo is invalid
			throw new InvalidParamException(String.format(ERROR_INVALID_COMMAND, commandArg));
		}
	}
	
	// Display and displaydone
	private void parseDisplay(String arg)
			throws InvalidParamException {
		if (!arg.isEmpty()) {
			// Only continue checking if a parameter is provided
			if (isInteger(arg) && Integer.parseInt(arg) > 0) {
				// Display or displaydone ID
				pt.setId(Integer.parseInt(arg));
			} else {
				String searchTerm = extractParameter("", arg).trim();

				if (!searchTerm.isEmpty()) {
					pt.setSearchKey(searchTerm);
				}

				boolean hasSortOrder = false;
				boolean isAscending = false;
				String sortBy = extractParameter("+", arg);

				if (!sortBy.isEmpty()) {
					isAscending = true;
					hasSortOrder = true;
				} else {
					sortBy = extractParameter("-", arg);

					if (!sortBy.isEmpty()) {
						isAscending = false;
						hasSortOrder = true;
					}
				}

				if (hasSortOrder) {
					if (isValidSortCrit(sortBy)) {
						pt.setHasSortOrder(true);
						pt.setIsAscending(isAscending);
						pt.setSortCrit(sortBy);
					} else {
						throw new InvalidParamException(ERROR_INVALID_SORT_PARAMS);
					}
				}
			}
		}
	}
	
	// Edit
	private void parseEdit(String commandArg) throws InvalidParamException {
		if (commandArg.isEmpty() || getRemainingArgument(commandArg).isEmpty()) {
			// Invalid number of parameters
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_EDIT);
		} else if (!isInteger(getFirstWord(commandArg))
				   || Integer.parseInt(getFirstWord(commandArg)) <= 0) {
			// ID is not a positive integer
			throw new InvalidParamException(ERROR_ID_NOT_POSITIVE
											 + "\n" + ERROR_PARAMS_EDIT);
		} else {
			// ID is a positive integer
			// Continue parsing
			pt.setId(Integer.parseInt(getFirstWord(commandArg)));
			parseTaskCommands(CommandType.EDIT, getRemainingArgument(commandArg));
		}
	}
	
	// Exit
	private void parseExit(String commandArg) throws InvalidParamException {
		parseCommandWithoutParam(CommandType.EXIT, commandArg);
	}
	
	// Help
	private void parseHelp(String commandArg) throws InvalidParamException {
		parseCommandWithoutParam(CommandType.HELP, commandArg);
	}
	
	// Queue
	private void parseQueue(String commandArg) throws InvalidParamException {
		String[] splitParams = commandArg.split(" ");
		
		if (splitParams.length != 1 && splitParams.length != 2) {
			// Invalid number of parameters
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_QUEUE);
			
		} else if (isInteger(splitParams[0]) && Integer.parseInt(splitParams[0]) > 0) {
			// ID is a positive integer (valid)
			pt.setId(Integer.parseInt(splitParams[0]));
			
			// Check position
			if (splitParams.length == 2) {
				if (isInteger(splitParams[1]) && Integer.parseInt(splitParams[1]) > 0) {
					// Position is a positive integer (valid)
					pt.setPosition(Integer.parseInt(splitParams[1]));
				} else {
					// Position is not a positive integer (invalid)
					throw new InvalidParamException(String.format(ERROR_POSITION_NOT_POSITIVE,
																  splitParams[1]));
				}
			}
		} else {
			// ID is not a positive integer (invalid)
			throw new InvalidParamException(String.format(ERROR_ID_NOT_POSITIVE,
														  splitParams[0]));
		}
	}
	
	// Redo
	private void parseRedo(String commandArg) throws InvalidParamException {
		parseCommandWithoutParam(CommandType.REDO, commandArg);
	}
	
	// Save
	private void parseSave(String commandArg) throws InvalidParamException {
		parseCommandWithoutParam(CommandType.SAVE, commandArg);
	}
	
	// Saveto
	private void parseSaveto(String commandArg) throws InvalidParamException {
		if (commandArg.isEmpty()) {
			// No parameter given
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_SAVETO);
		} else {
			// File path is given
			// Checking for valid file path done in external storage
			pt.setPath(commandArg);
		}
	}
	
	// Setlimit
	private void parseSetlimit(String commandArg) throws InvalidParamException {
		if (commandArg.isEmpty()) {
			// No parameter given
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_LIMIT);
		} else if (!isInteger(commandArg) || Integer.parseInt(commandArg) < 0) {
			// Limit is not a non-negative integer
			throw new InvalidParamException(String.format(ERROR_LIMIT_NOT_NON_NEGATIVE, commandArg));
		} else {
			// Limit is a non-negative integer
			pt.setLimit(Integer.parseInt(commandArg));
		}
	}
	
	// Uncomplete
	private void parseUncomplete(String commandArg) throws InvalidParamException {
		parseCommandWithId(CommandType.UNCOMPLETE, commandArg);
	}
	
	// Undo
	private void parseUndo(String commandArg) throws InvalidParamException {
		parseCommandWithoutParam(CommandType.UNDO, commandArg);
	}
	
	// Command without param
	private void parseCommandWithoutParam(CommandType type, String arg)
			throws InvalidParamException {
		if (!arg.isEmpty()) {
			// Parameter is given
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n"
					+ String.format(ERROR_PARAMS_NONE, commandTypeToString(type)));
		}
	}
	
	// Command with id
	private void parseCommandWithId(CommandType type, String arg)
			throws InvalidParamException {
		if (arg.isEmpty()) {
			// No parameter given
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n"
											+ String.format(ERROR_PARAMS_ID, commandTypeToString(type)));
		} else {
			if (isInteger(arg) && Integer.parseInt(arg) > 0) {
				// ID is a positive integer
				pt.setId(Integer.parseInt(arg));
			} else {
				// ID is not a positive integer
				throw new InvalidParamException(String.format(ERROR_ID_NOT_POSITIVE, arg));
			}
		}
	}
	
	private void parseTaskCommands(CommandType type, String arg) 
			throws InvalidParamException {
		String taskDesc = extractParameter("", arg);

		// Check task description
		if (!taskDesc.isEmpty()) {
			pt.setTaskDesc(taskDesc);
		} else if (type == CommandType.ADD) {
			throw new InvalidParamException(ERROR_INVALID_PARAMS + "\n" + ERROR_PARAMS_ADD);
		}

		// Extract relevant parameters
		String location = extractParameter("@", arg);
		String priority = extractParameter("!", arg);
		String cat = extractParameter("#", arg);
		String time = extractParameter("+", arg);
		String date = extractParameter("$", arg);
		String additional = extractParameter("&", arg);

		// Check location
		if (!location.isEmpty()) {
			if (location.equals(EMPTY) && type == CommandType.EDIT) {
				// Remove location
				pt.setLocation(TO_REMOVE);
			} else {
				pt.setLocation(location);
			}
		}

		// Check priority
		if (!priority.isEmpty()) {
			int priorityRank = convertPriority(priority);

			if (priority.equals(EMPTY) && type == CommandType.EDIT) {
				// Remove priority
				pt.setPriority(0);
			} else {
				if (priorityRank == -1) {
					throw new InvalidParamException(ERROR_INVALID_PRIORITY);
				} else {
					pt.setPriority(priorityRank);
				}
			}
		}

		// Check category
		if (!cat.isEmpty()) {
			if (cat.equals(EMPTY) && type == CommandType.EDIT) {
				// Remove category
				pt.setCategory(TO_REMOVE);
			} else {
				pt.setCategory(cat);
			}
		}

		// Check date and time
		if (!time.isEmpty() || !date.isEmpty()) {
			dp.reset();

			if ((time.equals(EMPTY) || date.equals(EMPTY)) && type == CommandType.EDIT) {
				// Remove date and time
				pt.setEndDate(dp.getRemovalDate());

			} else {
				Calendar startDate = null;
				Calendar startTime = null;
				Calendar endDate = null;
				Calendar endTime = null;
				String[] times, dates;

				try {
					if (time.isEmpty()) {
						// Time not specified
						dates = splitEventDate(date);

						if (dates.length == 1) {
							// Deadline
							endDate = dp.combineDateTime(dp.parseDate(date), dp.getDefaultEndTime());

						} else if (dates.length == 2) {
							// Event
							startDate = dp.combineDateTime(dp.parseDate(dates[0]), dp.getDefaultStartTime());
							endDate = dp.combineDateTime(dp.parseDate(dates[1]), dp.getDefaultEndTime());
							boolean hasEndYear = dp.hasYear();

							if (endDate.before(startDate)) {
								if (hasEndYear) {
									throw new InvalidParamException(ERROR_START_AFTER_END);
								} else {
									endDate = dp.getNextYear(endDate);
								}
							}

						} else {
							// Unrecognized format
							throw new InvalidParamException(ERROR_INVALID_DATE);
						}
					} else if (date.isEmpty()) {
						// Date not specified
						times = splitEventDate(time);

						if (times.length == 1) {
							// Deadline
							if (type == CommandType.EDIT)  {
								endTime = dp.parseTime(time);

								if (dp.isDateOver(endTime)) {
									endTime = dp.getNextDay(endTime);
								}
							} else {
								endDate = dp.getDefaultDate();

								if (dp.isDateOver(dp.combineDateTime(endDate, dp.parseTime(time)))) {
									endDate = dp.getNextDay(endDate);
								}

								endDate = dp.combineDateTime(endDate, dp.parseTime(time));
							}

						} else if (times.length == 2) {
							// Event
							if (type == CommandType.EDIT) {
								startTime = dp.parseTime(times[0]);
								endTime = dp.parseTime(times[1]);

								if (dp.isDateOver(startTime)) {
									startTime = dp.getNextDay(startTime);
									endTime = dp.getNextDay(endTime);
								}

								if (endTime.before(startTime)) {
									endTime = dp.getNextDay(endTime);
								}										
							} else {
								startDate = dp.getDefaultDate();

								if (dp.isDateOver(dp.combineDateTime(startDate, dp.parseTime(times[0])))) {
									startDate = dp.getNextDay(startDate);
								}

								endDate = startDate;
								startDate = dp.combineDateTime(startDate, dp.parseTime(times[0]));
								endDate = dp.combineDateTime(endDate, dp.parseTime(times[1]));

								if (endDate.before(startDate)) {
									endDate = dp.getNextDay(endDate);
								}
							}

						} else {
							// Unrecognized format
							throw new InvalidDateException(ERROR_INVALID_TIME);
						}
					} else {
						dates = splitEventDate(date);
						times = splitEventDate(time);

						if (dates.length == times.length) {
							if (dates.length == 1) {
								// Deadline
								endDate = dp.combineDateTime(dp.parseDate(date), dp.parseTime(time));
								
								if (dp.isDateOver(endDate)) {
									throw new InvalidParamException(ERROR_DATE_OVER);
								}

								if (type == CommandType.EDIT) {
									endTime = dp.parseTime(time);
								}

							} else if (dates.length == 2) {
								// Multiple day event
								startDate = dp.combineDateTime(dp.parseDate(dates[0]), dp.parseTime(times[0]));
								endDate = dp.combineDateTime(dp.parseDate(dates[1]), dp.parseTime(times[1]));
								boolean hasEndYear = dp.hasYear();
								
								if (dp.isDateOver(endDate) || dp.isDateOver(startDate)) {
									throw new InvalidParamException(ERROR_DATE_OVER);
								} else if (endDate.before(startDate)) {
									if (hasEndYear) {
										throw new InvalidParamException(ERROR_START_AFTER_END);
									} else {
										endDate = dp.getNextYear(endDate);
									}
								}

								if (type == CommandType.EDIT) {
									startTime = dp.parseTime(times[0]);
									endTime = dp.parseTime(times[1]);
								}

							} else {
								// Unrecognized format
								throw new InvalidParamException(ERROR_INVALID_EVENT_FORMAT);
							}
						} else if (dates.length == 1 && times.length == 2) {
							// Same day event
							startDate = dp.combineDateTime(dp.parseDate(date), dp.parseTime(times[0]));
							endDate = dp.combineDateTime(dp.parseDate(date), dp.parseTime(times[1]));
							
							if (dp.isDateOver(endDate) || dp.isDateOver(startDate)) {
								throw new InvalidParamException(ERROR_DATE_OVER);
							}

							if (endDate.before(startDate)) {
								endDate = dp.getNextDay(endDate);
							}

							if (type == CommandType.EDIT) {
								startTime = dp.parseTime(times[0]);
								endTime = dp.parseTime(times[1]);
							}

						} else {
							// Unrecognized format
							throw new InvalidParamException(ERROR_INVALID_EVENT_FORMAT);
						}
					}

					// Setting the parameters in ProtoTask
					if (startDate != null) {
						pt.setStartDate(startDate);
					}

					if (startTime != null) {
						pt.setStartTime(startTime);
					}

					if (endDate != null) {
						pt.setEndDate(endDate);
					}

					if (endTime != null) {
						pt.setEndTime(endTime);
					}
				} catch (InvalidDateException ide) {
					throw new InvalidParamException(ide.getMessage());
				}
			}
		}

		// Check additional
		if (!additional.isEmpty()) {
			if (additional.equals(EMPTY) && type == CommandType.EDIT) {
				pt.setAdditional(TO_REMOVE);
			} else {
				pt.setAdditional(additional);
			}
		}
	}
	
	/**
	 * This method extracts the parameter for a specific symbol from user entered command.
	 * Text enclosed within inverted commas are ignored when checking for parameter symbol.
	 * 
	 * @param symbol Symbol to indicate where to extract from.
	 * @param commandArg User entered command (without the first word).
	 * @return Contents for the parameter.
	 * @throws InvalidParamException if the inverted commas don't match.
	 */
	private String extractParameter(String symbol, String commandArg)
			throws InvalidParamException {
		boolean toCheck = true;
		boolean isInParam = false;
		boolean isEmpty = false;
		String parameter = "";
		char symbolChar = ' ';

		if (symbol.isEmpty()) {
			// For getting task description and search term
			isInParam = true;
		} else {
			symbolChar = symbol.charAt(0);
		}

		for (int i = 0; i < commandArg.length(); i++) {
			if (commandArg.charAt(i) == '"') {
				toCheck = !toCheck;
			} else {
				if (isInParam) {
					// Within the parameter
					if (toCheck) {
						if (i == 0 && paramSymbols.contains(commandArg.charAt(i) + "")) {
							// Special case for empty task description and search term
							isInParam = false;
							break;
						} else if (commandArg.charAt(i) == ' ' && i + 1 != commandArg.length()
								   && paramSymbols.contains(commandArg.charAt(i + 1) + "")) {
							
							if (commandArg.charAt(i + 1) != '-') {
								isInParam = false;
								
								if (parameter.trim().isEmpty()) {
									// Parameter is empty - remove parameter
									isEmpty = true;
								}
								
								break;
							} else {
								// Special case for event dates
								// e.g. 1 Jan - 31 Dec
								parameter += commandArg.charAt(i);
							}
						} else {
							parameter += commandArg.charAt(i);
						}
					} else {
						parameter += commandArg.charAt(i);
					}
				} else {
					// Not within the parameter
					if (toCheck && commandArg.charAt(i) == symbolChar) {
						if (i == 0 || commandArg.charAt(i - 1) == ' ') {
							isInParam = true;
						}
					}
				}
			}
		}
		
		if (!toCheck) {
			// Odd number of inverted commas - invalid
			throw new InvalidParamException(ERROR_ODD_INVERTED_COMMAS);
		} else {
			if (isEmpty) {
				// Remove parameter
				return EMPTY;
			} else if (isInParam && parameter.trim().isEmpty()) {
				// Remove parameter
				return EMPTY;
			} else {
				return parameter.trim();
			}
		}
	}
	
	/**
	 * This method converts the user entered priorities into integer priorities.
	 * (High = 1, medium = 2, low = 3, invalid priority = -1)
	 * 
	 * @param priority User entered String for priority.
	 * @return Integer corresponding to priority.
	 */
	private int convertPriority(String priority) {
		if (priority.equalsIgnoreCase("high")) {
			return 1;
		} else if (priority.equalsIgnoreCase("medium")
				   || priority.equalsIgnoreCase("med")) {
			return 2;
		} else if (priority.equalsIgnoreCase("low")) {
			return 3;
		} else {
			return -1;
		}
	}
	
	/**
	 * This method checks if the sort criteria provided by user is
	 * a valid sort criteria.
	 * 
	 * @param sortParam User entered String for sort criteria
	 * @return True is sort criteria is valid, false otherwise.
	 */
	private boolean isValidSortCrit(String sortParam) {
		return paramSymbols.substring(1).contains(sortParam);
	}
	
	/**
	 * This method checks whether user entered a range of date or time,
	 * separates the starting date and ending date, and returns both in an array.
	 * If no range is found, the original String is also returned in an length 1 array.
	 * 
	 * @param s String to check for date range.
	 * @return Array with start and end date separated.
	 */
	private String[] splitEventDate(String s) {
		String[] result;
		if (s.contains(" - ")) {
			result = s.split("\\s-\\s");
		} else if (s.contains(" to ")) {
			result = s.split("\\sto\\s");
		} else {
			String[] ss = {s};
			return ss;
		}
		
		// Fix for relative day of week dates
		// e.g. Next mon to fri --> next mon to next fri
		if (result[0].startsWith("next") && !result[1].startsWith("next")) {
			result[1] = "next " + result[1];
		}
		
		return result;
	}
	
	/**
	 * This method extracts the first word (space delimited) from the user command.
	 * It returns the entire command if the command is a single word.
	 * 
	 * @param command User input command.
	 * @return First word in the command.
	 */
	private String getFirstWord(String command) {
		return command.split(" ")[0];
	}
	
	/**
	 * This method extracts the remainder of the user command without the first word.
	 * It returns an empty string if the command is a single word.
	 * 
	 * @param command User input command.
	 * @return Command without the first word.
	 */
	private String getRemainingArgument(String command) {
		int i = command.indexOf(" ");
		
		if (i == -1) {
			return "";
		} else {
			return command.substring(i + 1, command.length()).trim();
		}
	}
	
	/**
	 * This method converts a command alias into its corresponding
	 * CommandType enum constant.
	 * 
	 * @param alias Command alias.
	 * @return CommandType enum constant for the command alias given, or CommandType.ERROR
	 * 		   if no such command alias found.
	 */
	private CommandType convertAliasToDefault(String alias) {
		
		CommandType type = getCommandType(alias);
		
		if (type == CommandType.ERROR && commandTable.contains(alias)) {
			// Alias is custom name for a command type
			Enumeration<String> commandTableKeys = commandTable.keys();
			
			while (commandTableKeys.hasMoreElements()) {
				String key = commandTableKeys.nextElement();
				if (commandTable.get(key).equalsIgnoreCase(alias)) {
					type = getCommandType(key);
					break;
				}
			}
		}
		
		return type;
	}
	
	/**
	 * This method converts a CommandType enum constant to its String equivalent.
	 * 
	 * @param type CommandType enum constant.
	 * @return String corresponding to CommandType.
	 */
	private String commandTypeToString(CommandType type) {
		return type.toString().toLowerCase();
	}
	
	/**
	 * This method checks if a String is an integer.
	 * 
	 * @param s String to check. 
	 * @return True if String is an integer, false otherwise.
	 */
	private boolean isInteger(String s) {
		boolean isInt = true;
		
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException nfe) {
			isInt = false;
		}
		
		return isInt;
	}
	
	/**
	 * This method creates a ProtoTask with command set to error.
	 * Used for sending error messages back to user.
	 * 
	 * @param errorMsg Error message to be sent to user.
	 */
	private void createErrorTask(String errorMsg) {
		pt = new ProtoTask("error");
		pt.setErrorMessage(errorMsg);
	}
}
```
###### \src\tucklife\parser\ParserTest.java
``` java
package tucklife.parser;

import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Hashtable;

import org.junit.Before;
import org.junit.Test;

public class ParserTest {
	
	Parser p;
	ProtoTask pt;
	SimpleDateFormat sdf;

	@Before
	public void setUp() throws Exception {
		p = new Parser();
		p.loadCommands(new Hashtable<String, String>());
		sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
	}

	@Test
	public void testAdd() {
		// 0 parameters
		assertTrue(p.parse("add").isError());
		
		// No task description
		assertTrue(p.parse("add !high").isError());
		
		// Task description
		assertEquals("Command type: add\nParameters:\nTask description: work\n",
					 p.parse("add work").toString());
		assertEquals("Command type: add\nParameters:\nTask description: finish all my work!\n",
					 p.parse("add finish all my work!").toString());
		assertEquals("Command type: add\nParameters:\nTask description: 123\n",
					 p.parse("add 123").toString());
		
		// Location - @
		assertEquals("Command type: add\nParameters:\nTask description: work\nLocation: office\n",
					 p.parse("add work @office").toString());
		assertEquals("Command type: add\nParameters:\nTask description: dinner\nLocation: atas restaurant\n",
					 p.parse("add dinner @atas restaurant").toString());
		
		// Priority - !
		assertEquals("Command type: add\nParameters:\nTask description: very important task\nPriority: 1\n",
					 p.parse("add very important task !high").toString());
		assertEquals("Command type: add\nParameters:\nTask description: normal task\nPriority: 2\n",
				 	 p.parse("add normal task !medium").toString());
		assertEquals("Command type: add\nParameters:\nTask description: optional task\nPriority: 3\n",
				 	 p.parse("add optional task !low").toString());
		
		// Invalid priority
		assertTrue(p.parse("add invalid priority !extremely important").isError());
		
		// Category - #
		assertEquals("Command type: add\nParameters:\nTask description: unit testing\nCategory: CS2103T\n",
					 p.parse("add unit testing #CS2103T").toString());
		assertEquals("Command type: add\nParameters:\nTask description: do report\nCategory: top secret project\n",
					 p.parse("add do report #top secret project").toString());
		
		// Additional information - &
		assertEquals("Command type: add\nParameters:\nTask description: dinner with mum\n"
					 + "Additional information: sushi! :D\n",
					 p.parse("add dinner with mum &sushi! :D").toString());
		assertEquals("Command type: add\nParameters:\nTask description: meeting\n"
					 + "Additional information: about sales performance. Prepare to present.\n",
					 p.parse("add meeting &about sales performance. Prepare to present.").toString());
		
		// All parameters
		assertEquals("Command type: add\nParameters:\nTask description: meeting with boss\n"
					 + "Location: boss's office\nCategory: top secret project\nAdditional information: "
					 + "BIG BOSS COMING!!!\nPriority: 1\nEnd date: Sat, 28 May 2016 10:00\n",
					 p.parse("add meeting with boss !high +10am $28-may-2016 @boss's office"
							 + " &BIG BOSS COMING!!! #top secret project").toString());
		
		// Some parameters in different order
		assertEquals("Command type: add\nParameters:\nTask description: buy office supplies\n"
					 + "Category: misc\nPriority: 2\nEnd date: Tue, 24 May 2016 23:59\n",
					 p.parse("add buy office supplies $24 may 16 #misc !medium").toString());
	}
	
	@Test
	public void testAddForDates() {
		// Date - $
		// Single date
		assertEquals("Command type: add\nParameters:\nTask description: job interview\n"
					 + "End date: Wed, 25 May 2016 23:59\n",
					 p.parse("add job interview $25/5/16").toString());

		// Invalid dates
		assertTrue(p.parse("add my birthday $30 feb").isError());
		assertTrue(p.parse("add task $not a date").isError());
		
		// Date that has passed
		assertTrue(p.parse("add overdue date $1 jan 2015").isError());

		// Event dates
		// Using to
		assertEquals("Command type: add\nParameters:\nTask description: work trip\n"
					 + "Start date: Mon, 23 May 2016 00:00\n"
					 + "End date: Fri, 27 May 2016 23:59\n",
					 p.parse("add work trip $23may to 27may").toString());

		// Using dash
		assertEquals("Command type: add\nParameters:\nTask description: work trip\n"
					 + "Start date: Mon, 23 May 2016 00:00\n"
					 + "End date: Fri, 27 May 2016 23:59\n",
					 p.parse("add work trip $23may - 27may").toString());

		// Invalid event dates
		assertTrue(p.parse("add some event $29 feb - 30 feb").isError());
		assertTrue(p.parse("add task $30 feb - 1 mar").isError());
		
		// Start date has passed
		assertTrue(p.parse("add start over $25/12/10 - 1/1/11").isError());
		
		// End date has passed
		assertTrue(p.parse("add end over $today - 1/1/16").isError());

		// Time - +
		// Getting the correct date based on current date
		Calendar c1 = Calendar.getInstance();
		if (c1.get(Calendar.HOUR_OF_DAY) > 16) {
			c1.add(Calendar.DATE, 1);
		}
		c1.set(Calendar.HOUR_OF_DAY, 17);
		c1.set(Calendar.MINUTE, 0);

		assertEquals("Command type: add\nParameters:\nTask description: evening run\n"
					 + "End date: " + sdf.format(c1.getTime()) + "\n",
					 p.parse("add evening run +5pm").toString());

		// This is most likely going to be set for next day
		Calendar c2 = Calendar.getInstance();
		if (c2.get(Calendar.HOUR_OF_DAY) > 0
			|| (c2.get(Calendar.HOUR_OF_DAY) == 0 && c2.get(Calendar.MINUTE) > 1)) {
			c2.add(Calendar.DATE, 1);
		}
		c2.set(Calendar.HOUR_OF_DAY, 0);
		c2.set(Calendar.MINUTE, 1);

		assertEquals("Command type: add\nParameters:\nTask description: midnight run\n"
					 + "End date: " + sdf.format(c2.getTime()) + "\n",
					 p.parse("add midnight run +12:01am").toString());

		// Invalid times
		assertTrue(p.parse("add 13 o'clock +13pm").isError());
		assertTrue(p.parse("add task +not a time").isError());
		
		// Both date and time - $ and +
		// Deadline
		assertEquals("Command type: add\nParameters:\nTask description: submit report\n"
					+ "End date: Mon, 05 Sep 2016 18:00\n",
					p.parse("add submit report $5/9 +6pm").toString());
		
		// Deadline that has passed
		assertTrue(p.parse("add submit overdue report $1/1/16 +9am").isError());
		
		// Event
		// Multiple day event
		assertEquals("Command type: add\nParameters:\nTask description: roadshow\n"
					 + "Start date: Wed, 18 May 2016 09:00\nEnd date: Sun, 22 May 2016 21:00\n",
					 p.parse("add roadshow $18/5 to 22/5 +9am to 9pm").toString());
		
		// Event that has passed
		assertTrue(p.parse("add roadshow over $18/5/15 to 22/5/15 +9am to 9pm").isError());
		
		// Start date after end date
		assertTrue(p.parse("add travel in time $tmr to today").isError());
	}
	
	@Test
	public void testChange() {
		// < 2 parameters
		assertTrue(p.parse("change").isError());
		assertTrue(p.parse("change sth").isError());
		
		// 2 parameters
		
		// Old command is invalid
		assertTrue(p.parse("change sth sthelse").isError());
		
		// Old command is valid
		
		// Old command is default command name
		// New command is not used
		// (Valid)
		assertEquals("Command type: change\nParameters:\n"
					 + "Change message: 'delete' has been changed to 'dl'!\n",
					 p.parse("change delete dl").toString());
		
		// Checking that new command indeed works
		assertEquals("Command type: delete\nParameters:\nID: 1\n", p.parse("dl 1").toString());
		
		// Checking that old command still works too
		assertEquals("Command type: delete\nParameters:\nID: 1\n", p.parse("delete 1").toString());
		
		// New command has already been set
		assertEquals("Command type: change\nParameters:\n"
					 + "Change message: 'delete' is the same as 'dl'! No change occurred.\n",
					 p.parse("change delete dl").toString());
		
		assertEquals("Command type: change\nParameters:\n"
				 + "Change message: 'dl' is the same as 'dl'! No change occurred.\n",
				 p.parse("change dl dl").toString());
		
		// New command is a default command name
		assertTrue(p.parse("change help add").isError());
		
		// New command is a used alias
		assertTrue(p.parse("change help dl").isError());
		
		// Old command is alias
		assertEquals("Command type: change\nParameters:\n"
					 + "Change message: 'dl' has been changed to 'del'!\n",
					 p.parse("change dl del").toString());
	}
	
	@Test
	public void testComplete() {
		// 0 parameters
		assertTrue(p.parse("complete").isError());

		// 1 parameter

		// ID not a number
		assertTrue(p.parse("complete abc").isError());

		// ID < 1
		assertTrue(p.parse("complete -1").isError());

		// ID >= 1
		assertEquals("Command type: complete\nParameters:\nID: 5\n", p.parse("complete 5").toString());

		// Boundary
		assertTrue(p.parse("complete 0").isError());
		assertEquals("Command type: complete\nParameters:\nID: 1\n", p.parse("complete 1").toString());
		assertEquals("Command type: complete\nParameters:\nID: 2\n", p.parse("complete 2").toString());

		// > 1 parameter
		assertTrue(p.parse("complete 1 1").isError());
	}

	@Test
	public void testDelete() {
		// 0 parameters
		assertTrue(p.parse("delete").isError());

		// 1 parameter

		// ID not a number
		assertTrue(p.parse("delete abc").isError());

		// ID < 1
		assertTrue(p.parse("delete -1").isError());

		// ID >= 1
		assertEquals("Command type: delete\nParameters:\nID: 5\n", p.parse("delete 5").toString());

		// Boundary
		assertTrue(p.parse("delete 0").isError());
		assertEquals("Command type: delete\nParameters:\nID: 1\n", p.parse("delete 1").toString());
		assertEquals("Command type: delete\nParameters:\nID: 2\n", p.parse("delete 2").toString());

		// > 1 parameter
		assertTrue(p.parse("delete 1 1").isError());
	}
	
	@Test
	public void testDemo() {
		// 0 parameters
		assertTrue(p.parse("demo").isError());
		
		// 1 parameter
		
		// Invalid command
		assertTrue(p.parse("demo notacommand").isError());
		
		// Valid command
		assertEquals("Command type: demo\nParameters:\nDemo command: add\n", p.parse("demo add").toString());
		assertEquals("Command type: demo\nParameters:\nDemo command: help\n", p.parse("demo help").toString());
		assertEquals("Command type: demo\nParameters:\nDemo command: undo\n", p.parse("demo undo").toString());
		
		// > 1 parameter
		assertTrue(p.parse("demo demo demo").isError());
	}
	
	@Test
	public void testDisplay() {
		// 0 parameters
		assertEquals("Command type: display\nParameters:\n", p.parse("display").toString());
		
		//TODO
	}
	
	@Test
	public void testDisplaydone() {
		// 0 parameters
		assertEquals("Command type: displaydone\nParameters:\n", p.parse("displaydone").toString());
		
		//TODO
	}
	
	@Test
	public void testEdit() {
		// 0 parameters
		assertTrue(p.parse("edit").isError());

		// 1 parameter
		assertTrue(p.parse("edit !high").isError());
		assertTrue(p.parse("edit 1").isError());
		
		// > 1 parameter
		
		// ID is not a number
		assertTrue(p.parse("edit something here").isError());
		
		// ID < 1
		assertTrue(p.parse("edit -1 new task name").isError());
		
		// ID >= 1

		// Task description
		assertEquals("Command type: edit\nParameters:\nTask description: work\nID: 1\n",
					 p.parse("edit 1 work").toString());
		assertEquals("Command type: edit\nParameters:\nTask description: finish all my work!\nID: 1\n",
					 p.parse("edit 1 finish all my work!").toString());
		assertEquals("Command type: edit\nParameters:\nTask description: 123\nID: 1\n",
				 	 p.parse("edit 1 123").toString());

		// Location - @
		assertEquals("Command type: edit\nParameters:\nLocation: office\nID: 1\n",
					 p.parse("edit 1 @office").toString());
		assertEquals("Command type: edit\nParameters:\nLocation: atas restaurant\nID: 1\n",
					 p.parse("edit 1 @atas restaurant").toString());

		// Priority - !
		assertEquals("Command type: edit\nParameters:\nPriority: 1\nID: 1\n",
					 p.parse("edit 1 !high").toString());
		assertEquals("Command type: edit\nParameters:\nPriority: 2\nID: 1\n",
					 p.parse("edit 1 !medium").toString());
		assertEquals("Command type: edit\nParameters:\nPriority: 3\nID: 1\n",
					 p.parse("edit 1 !low").toString());

		// Invalid priority
		assertTrue(p.parse("edit 1 !extremely important").isError());

		// Category - #
		assertEquals("Command type: edit\nParameters:\nCategory: CS2103T\nID: 1\n",
					 p.parse("edit 1 #CS2103T").toString());
		assertEquals("Command type: edit\nParameters:\nCategory: top secret project\nID: 1\n",
					 p.parse("edit 1 #top secret project").toString());

		// Additional information - &
		assertEquals("Command type: edit\nParameters:\nAdditional information: sushi! :D\nID: 15\n",
					 p.parse("edit 15 &sushi! :D").toString());
		assertEquals("Command type: edit\nParameters:\nAdditional information: about sales performance. "
					 + "Prepare to present.\nID: 15\n",
					 p.parse("edit 15 &about sales performance. Prepare to present.").toString());

		// Date - $
		assertEquals("Command type: edit\nParameters:\nID: 15\nEnd date: Wed, 25 May 2016 23:59\n",
					 p.parse("edit 15 $25/5/16").toString());

		// Invalid dates
		assertTrue(p.parse("edit 15 $30 feb").isError());
		assertTrue(p.parse("edit 15 $not a date").isError());

		// Time - +
		// Getting the correct date based on current date
		Calendar c1  = Calendar.getInstance();
		if (c1.get(Calendar.HOUR_OF_DAY) > 16) {
			c1.add(Calendar.DATE, 1);
		}
		
		c1.set(Calendar.HOUR_OF_DAY, 17);
		c1.set(Calendar.MINUTE, 0);
		
		assertEquals("Command type: edit\nParameters:\nID: 15\nEnd time: "
					 + sdf.format(c1.getTime()) + "\n",
					 p.parse("edit 15 +5pm").toString());

		// Invalid times
		assertTrue(p.parse("edit 15 +13pm").isError());
		assertTrue(p.parse("edit 15 +not a time").isError());

		// All parameters
		// Getting the correct date based on current date
		Calendar c2 = Calendar.getInstance();
		c2.set(Calendar.HOUR_OF_DAY, 10);
		c2.set(Calendar.MINUTE, 0);
		
		assertEquals("Command type: edit\nParameters:\nTask description: meeting with boss\n"
					 + "Location: boss's office\nCategory: top secret project\nAdditional information: "
					 + "BIG BOSS COMING!!!\nPriority: 1\nID: 15\nEnd date: Sat, 28 May 2016 10:00\n"
					 + "End time: " + sdf.format(c2.getTime()) + "\n",
					 p.parse("edit 15 meeting with boss !high +10am $28-may-2016 @boss's office"
							 + " &BIG BOSS COMING!!! #top secret project").toString());

		// Some parameters
		assertEquals("Command type: edit\nParameters:\nCategory: misc\n"
					 + "Priority: 2\nID: 15\nEnd date: Tue, 24 May 2016 23:59\n",
					 p.parse("edit 15 $24 may 16 #misc !medium").toString());
	}
	
	@Test
	public void testExit() {
		// 0 parameters
		assertEquals("Command type: exit\nParameters:\n", p.parse("exit").toString());
		
		// Has parameters
		assertTrue(p.parse("exit 1").isError());
	}
	
	@Test
	public void testHelp() {
		// 0 parameters
		assertEquals("Command type: help\nParameters:\n", p.parse("help").toString());

		// Has parameters
		assertTrue(p.parse("help me").isError());
	}
	
	@Test
	public void testQueue() {
		// 0 parameters
		assertTrue(p.parse("queue").isError());
		
		// 1 parameter
		
		// ID not a number
		assertTrue(p.parse("queue up").isError());
		
		// ID < 1
		assertTrue(p.parse("queue -1").isError());
		
		// ID >= 1
		assertEquals("Command type: queue\nParameters:\nID: 5\n", p.parse("queue 5").toString());
		
		// Boundary
		assertTrue(p.parse("queue 0").isError());
		assertEquals("Command type: queue\nParameters:\nID: 1\n", p.parse("queue 1").toString());
		assertEquals("Command type: queue\nParameters:\nID: 2\n", p.parse("queue 2").toString());
		
		// 2 parameters
		
		// Valid ID, invalid position
		assertTrue(p.parse("queue 5 position").isError());
		
		// Invalid ID, valid position
		assertTrue(p.parse("queue -1 2").isError());
		
		// Invalid ID, invalid position
		assertTrue(p.parse("queue up please").isError());
		
		// Position not a number
		assertTrue(p.parse("queue 1 abc").isError());
		
		// Position < 1
		assertTrue(p.parse("queue 1 -5").isError());
		
		// Position >= 1
		assertEquals("Command type: queue\nParameters:\nID: 1\nPosition: 5\n",
					 p.parse("queue 1 5").toString());
		
		// Boundary
		assertTrue(p.parse("queue 0 -1").isError());
		assertEquals("Command type: queue\nParameters:\nID: 1\nPosition: 1\n",
					 p.parse("queue 1 1").toString());
		assertEquals("Command type: queue\nParameters:\nID: 2\nPosition: 2\n",
				 	 p.parse("queue 2 2").toString());
		
		// > 2 parameters
		assertTrue(p.parse("queue 1 2 3").isError());
	}
	
	@Test
	public void testRedo() {
		// 0 parameters
		assertEquals("Command type: redo\nParameters:\n", p.parse("redo").toString());

		// Has parameters
		assertTrue(p.parse("redo 1").isError());
	}
	
	@Test
	public void testSave() {
		// 0 parameters
		assertEquals("Command type: save\nParameters:\n", p.parse("save").toString());

		// Has parameters
		assertTrue(p.parse("save me").isError());
	}
	
	@Test
	public void testSaveto() {
		// 0 parameters
		assertTrue(p.parse("saveto").isError());

		// Has parameters
		assertEquals("Command type: saveto\nParameters:\nPath: myfile.txt\n",
					 p.parse("saveto myfile.txt").toString());		
		assertEquals("Command type: saveto\nParameters:\nPath: C:/Documents/myfile.txt\n",
					 p.parse("saveto C:/Documents/myfile.txt").toString());
	}

	@Test
	public void testSetlimit() {
		// 0 parameters
		assertTrue(p.parse("setlimit").isError());

		// 1 parameter

		// ID not a number
		assertTrue(p.parse("setlimit abc").isError());

		// ID < 0
		assertTrue(p.parse("setlimit -1").isError());

		// ID >= 0
		assertEquals("Command type: delete\nParameters:\nID: 5\n", p.parse("delete 5").toString());

		// Boundary
		assertTrue(p.parse("delete 0").isError());
		assertEquals("Command type: delete\nParameters:\nID: 1\n", p.parse("delete 1").toString());
		assertEquals("Command type: delete\nParameters:\nID: 2\n", p.parse("delete 2").toString());

		// > 1 parameter
		assertTrue(p.parse("delete 1 1").isError());
	}
	
	@Test
	public void testUndo() {
		// 0 parameters
		assertEquals("Command type: undo\nParameters:\n", p.parse("undo").toString());

		// Has parameters
		assertTrue(p.parse("undo 1").isError());
	}
	
	@Test
	public void testInvalidCommand() {
		// Invalid command without parameters
		assertTrue(p.parse("notacommand").isError());
		assertTrue(p.parse("addd").isError());
		
		// Invalid command with parameters
		assertTrue(p.parse("not a command").isError());
	}
}
```
###### \src\tucklife\parser\ProtoTask.java
``` java
package tucklife.parser;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public class ProtoTask {
	
	private String command;
	private String taskDesc;
	private String location;
	private String category;
	private String additional;
	private String searchKey;
	private String sortCrit;
	private String demoCommand;
	private String path;
	private String changeMessage;
	
	private int priority = -1;
	private int id = -1;
	private int limit = -1;
	private int position = -1;
	
	private boolean hasSortOrder = false;
	private boolean isAscending = false;
	
	private Calendar startDate;
	private Calendar startTime;
	private Calendar endDate;
	private Calendar endTime;
	private SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
	
	private boolean isError;
	private String errorMessage;
	
	/*****************************
	 * Constructor for ProtoTask *
	 *****************************/
	public ProtoTask(String commandType) {
		if (commandType.equalsIgnoreCase("error")) {
			isError = true;
		} else {
			isError = false;
			command = commandType;
		}
	}
	
	/**************************
	 * Getters for parameters *
	 **************************/
	public String getCommand() {
		return command;
	}
	
	public String getTaskDesc() {
		return taskDesc;
	}
	
	public String getLocation() {
		return location;
	}
	
	public String getCategory() {
		return category;
	}
	
	public String getAdditional() {
		return additional;
	}
	
	public String getSearchKey() {
		return searchKey;
	}
	
	public String getSortCrit() {
		return sortCrit;
	}
	
	public String getDemoCommand() {
		return demoCommand;
	}
	
	public String getPath() {
		return path;
	}
	
	public String getChangeMessage() {
		return changeMessage;
	}
	
	public int getPriority() {
		return priority;
	}
	
	public int getId() {
		return id;
	}
	
	public int getLimit() {
		return limit;
	}
	
	public int getPosition() {
		return position;
	}
	
	public boolean getHasSortOrder() {
		return hasSortOrder;
	}
	
	public boolean getIsAscending() {
		return isAscending;
	}
	
	public Calendar getStartDate() {
		return startDate;
	}
	
	public Calendar getEndDate() {
		return endDate;
	}
	
	public Calendar getStartTime() {
		return startTime;
	}
	
	public Calendar getEndTime() {
		return endTime;
	}
	
	public boolean isError() {
		return isError;
	}
	
	public String getErrorMessage() {
		return errorMessage;
	}
	
	/**************************
	 * Setters for parameters *
	 **************************/
	public void setTaskDesc(String td) {
		taskDesc = td;
	}
	
	public void setLocation(String l) {
		location = l;
	}
	
	public void setCategory(String c) {
		category = c;
	}
	
	public void setAdditional(String a) {
		additional = a;
	}
	
	public void setSearchKey(String sk) {
		searchKey = sk;
	}
	
	public void setSortCrit(String sc) {
		sortCrit = sc;
	}
	
	public void setDemoCommand(String dc) {
		demoCommand = dc;
	}
	
	public void setPath(String p) {
		path = p;
	}
	
	public void setChangeMessage(String cm) {
		changeMessage = cm;
	}

	public void setPriority(int p) {
		priority = p;
	}
	
	public void setId(int i) {
		id = i;
	}
	
	public void setLimit(int l) {
		limit = l;
	}
	
	public void setPosition(int p) {
		position = p;
	}
	
	public void setHasSortOrder(boolean s) {
		hasSortOrder = s;
	}
	
	public void setIsAscending(boolean a) {
		isAscending = a;
	}
	
	public void setStartDate(Calendar sd) {
		startDate = sd;
	}
	
	public void setStartTime(Calendar st) {
		startTime = st;
	}
	
	public void setEndDate(Calendar ed) {
		endDate = ed;
	}
	
	public void setEndTime(Calendar et) {
		endTime = et;
	}
	
	public void setErrorMessage(String em) {
		isError = true;
		errorMessage = em;
	}
	
	/*****************
	 * Other methods *
	 *****************/
	public String toString() {
		if (isError) {
			return "Error: " + errorMessage + "\n";
		} else {
			String toDisplay = "Command type: " + command + "\n";
			toDisplay += "Parameters:\n";

			if (taskDesc != null) {
				toDisplay += "Task description: " + taskDesc + "\n";
			}

			if (location != null) {
				toDisplay += "Location: " + location + "\n";
			}

			if (category != null) {
				toDisplay += "Category: " + category + "\n";
			}

			if (additional != null) {
				toDisplay += "Additional information: " + additional + "\n";
			}

			if (searchKey != null) {
				toDisplay += "Search keyword: " + searchKey + "\n";
			}

			if (sortCrit != null) {
				toDisplay += "Sort criteria: " + sortCrit + "\n";
			}

			if (demoCommand != null) {
				toDisplay += "Demo command: " + demoCommand + "\n";
			}

			if (path != null) {
				toDisplay += "Path: " + path + "\n";
			}
			
			if (changeMessage != null) {
				toDisplay += "Change message: " + changeMessage + "\n";
			}

			if (priority != -1) {
				toDisplay += "Priority: " + priority + "\n";
			}

			if (id != -1) {
				toDisplay += "ID: " + id + "\n";
			}
			
			if (limit != -1) {
				toDisplay += "Limit: " + limit + "\n";
			}
			
			if (position != -1) {
				toDisplay += "Position: " + position + "\n";
			}
			
			if (hasSortOrder) {
				if (isAscending) {
					toDisplay += "Sort order: ascending\n";
				} else {
					toDisplay += "Sort order: descending\n";
				}
			}

			if (startDate != null) {
				toDisplay += "Start date: " + sdf.format(startDate.getTime()) + "\n";
			}
			
			if (startTime != null) {
				toDisplay += "Start time: " + sdf.format(startTime.getTime()) + "\n";
			}

			if (endDate != null) {
				toDisplay += "End date: " + sdf.format(endDate.getTime()) + "\n";
			}
			
			if (endTime != null) {
				toDisplay += "End time: " + sdf.format(endTime.getTime()) + "\n";
			}


			return toDisplay;
		}
	}
}
```
###### \src\tucklife\parser\TestParser.java
``` java
package tucklife.parser;

import java.util.Scanner;
import java.util.Hashtable;

public class TestParser {
	
	// Only used for manual testing of parser
	
	private static Parser p;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		p = new Parser();
		p.loadCommands(new Hashtable<String, String>());
		
		while (true) {		
			System.out.print("Command? ");
			String command = sc.nextLine();

			if (command.equalsIgnoreCase("exit")) {
				sc.close();
				System.exit(0);
			}

			ProtoTask pt = p.parse(command);

			System.out.println(pt.toString());
		}
	}
}
```
