# A0111101N
###### \src\tucklife\storage\internal\SaveState.java
``` java
package tucklife.storage.internal;

import java.util.ArrayList;
import java.util.Iterator;

import tucklife.storage.Task;
import tucklife.storage.TaskList;

public class SaveState {
	
	//Stores the previous versions of toDoList, queueList and doneList
	private ArrayList<ArrayList<TaskList>> undoSaveState = new ArrayList<ArrayList<TaskList>>();
	private ArrayList<ArrayList<TaskList>> redoSaveState = new ArrayList<ArrayList<TaskList>>();

	public ArrayList<ArrayList<TaskList>> getUndoSaveState() {
		return undoSaveState;
	}

	public ArrayList<ArrayList<TaskList>> getRedoSaveState() {
		return redoSaveState;
	}
	
	public void storeUndoSaveState(TaskList toDoList, TaskList doneList) {
		ArrayList<TaskList> saveState = getSaveState(toDoList, doneList);

		if (undoSaveState.size() < 50) {
			undoSaveState.add(saveState);
		} else {
			undoSaveState.remove(0);
			undoSaveState.add(saveState);
		}
	}

	public void storeRedoSaveState(TaskList toDoList, TaskList doneList) {
		ArrayList<TaskList> saveState = getSaveState(toDoList, doneList);

		if (redoSaveState.size() < 50) {
			redoSaveState.add(saveState);
		} else {
			redoSaveState.remove(0);
			redoSaveState.add(saveState);
		}
	}

	private ArrayList<TaskList> getSaveState(TaskList toDoList, TaskList doneList) {
		ArrayList<TaskList> saveState = new ArrayList<TaskList>();

		TaskList oldToDoList = duplicateTaskList(toDoList);
		TaskList oldQueueList = getQueueListFromToDoList(oldToDoList);

		saveState.add(oldToDoList);
		saveState.add(oldQueueList);

		TaskList oldDoneList = duplicateTaskList(doneList);

		saveState.add(oldDoneList);
		return saveState;
	}
	
	//Ensures that the corresponding Tasks in the queueList and toDoList are the same object
	public TaskList getQueueListFromToDoList(TaskList oldToDoList) {
		oldToDoList.sort(null, true);
		TaskList oldQueueList = new TaskList();
		Iterator<Task> taskListIter = oldToDoList.iterator();
		while (taskListIter.hasNext()) {
			Task t = taskListIter.next();
			if (t.getQueueID() != -1) {
				oldQueueList.add(t);
			}
		}
		return oldQueueList;
	}

	private TaskList duplicateTaskList(TaskList originalList) {
		TaskList duplicateList = new TaskList();
		Iterator<Task> taskListIter = originalList.iterator();
		while (taskListIter.hasNext()) {
			//new Tasks are created because it's a new version
			Task t = new Task(taskListIter.next());
			duplicateList.add(t);
		}
		return duplicateList;
	}

	//Restores the previous versions of toDoList, queueList and doneList
	public TaskList[] restoreSaveState(String type) {
		ArrayList<TaskList> state;
		if (type.equals("undo")) {
			state = undoSaveState.remove(undoSaveState.size() - 1);
		} else {
			state = redoSaveState.remove(redoSaveState.size() - 1);
		}
		TaskList toDoList = state.get(0);
		TaskList queueList = state.get(1);
		TaskList doneList = state.get(2);
		TaskList[] tl = { toDoList, queueList, doneList };
		return tl;
	}

	public void prepareForUndo(TaskList toDoList, TaskList doneList) {
		storeUndoSaveState(toDoList, doneList);
		redoSaveState.clear();
	}

}
```
###### \src\tucklife\storage\internal\Storage.java
``` java
package tucklife.storage.internal;

import java.text.SimpleDateFormat;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;
import tucklife.storage.external.PrefsStorage;
import tucklife.storage.internal.StorageExceptions.InvalidDateException;
import tucklife.storage.internal.StorageExceptions.NothingToRedoException;
import tucklife.storage.internal.StorageExceptions.NothingToUndoException;
import tucklife.storage.internal.StorageExceptions.OverloadException;
import tucklife.storage.DataBox;
import tucklife.storage.Task;
import tucklife.storage.TaskList;

public class Storage {

	private static final Logger log = Logger.getLogger(Storage.class.getName());

	private static final String RETURN_MESSAGE_FOR_ADD = "{%1$s} has been added to TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_EDIT = "{%1$s} has been edited in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_DELETE = "{%1$s} has been deleted from TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_QUEUE = "{%1$s} has been added to TuckLife's queue at position {%2$s}!";
	private static final String RETURN_MESSAGE_FOR_SETLIMIT = "Limit has been set to %1$s in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_SETLIMIT_WHEN_ABOVE_LIMIT = RETURN_MESSAGE_FOR_SETLIMIT
			+ " Be aware that there are some days with more tasks than your new limit!";
	private static final String RETURN_MESSAGE_FOR_SETLIMIT_OFF = "Limit has been turned off in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_COMPLETE = "{%1$s} has been moved to TuckLife's done list!";
	private static final String RETURN_MESSAGE_FOR_UNCOMPLETE = "{%1$s} has been moved to TuckLife's to-do list!";

	private static final String RETURN_MESSAGE_FOR_NONEXISTENT_ID = "No task with id:%1$s in TuckLife's to-do list!";
	private static final String RETURN_MESSAGE_FOR_NONEXISTENT_ID_DONELIST = "No task with id:%1$s in TuckLife's done list!";

```
###### \src\tucklife\storage\internal\Storage.java
``` java
	private static final int defaultNumberOfDisplayedTasks = 20;

	private static TaskList toDoList;
	private static TaskList doneList;

	private static TaskList queueList;

	private static SaveState state;

	private static PrefsStorage pf;

	public Storage(DataBox db) {
		TaskList[] loadList = db.getLists();
		state = new SaveState();
		toDoList = loadList[0];
		doneList = loadList[1];
		//Generate queueList from toDoList so that the corresponding Tasks are the same object
		queueList = state.getQueueListFromToDoList(toDoList);
		pf = db.getPrefs();
		log.log(Level.FINE, "Storage object created");
	}

	public String undo() throws NothingToUndoException {
		if (state.getUndoSaveState().size() == 0) {
			throw new StorageExceptions.NothingToUndoException();
		}
		state.storeRedoSaveState(toDoList, doneList);
		TaskList[] tl = state.restoreSaveState("undo");
		toDoList = tl[0];
		queueList = tl[1];
		doneList = tl[2];
		return "undone";
	}

	public String redo() throws NothingToRedoException {
		if (state.getRedoSaveState().size() == 0) {
			throw new StorageExceptions.NothingToRedoException();
		}
		state.storeUndoSaveState(toDoList, doneList);
		TaskList[] tl = state.restoreSaveState("redo");
		toDoList = tl[0];
		queueList = tl[1];
		doneList = tl[2];
		return "redone";
	}

	public DataBox save() {
		TaskList[] saveList = new TaskList[2];
		saveList[0] = toDoList;
		saveList[1] = doneList;
		DataBox db = new DataBox(saveList, pf);
		return db;
	}

	public String add(ProtoTask task) throws OverloadException, InvalidDateException {
		Task newTask = new Task(task);
		toDoList.sort("$", true);
		if (isOverloaded(newTask)) {
			throw new StorageExceptions.OverloadException(pf.getOverloadLimit());
		} else {
			//method changes TaskLists, hence use state to save the old versions
			state.prepareForUndo(toDoList, doneList);
			toDoList.add(newTask);
			return String.format(RETURN_MESSAGE_FOR_ADD, newTask.displayAll());
		}
	}

	private boolean isOverloaded(Task newTask) {
		// dont count floating tasks and events
		if (!newTask.isDeadline()) {
			return false;
		}

		int limit = pf.getOverloadLimit();
		if (limit == -1) {
			return false;
		}
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy");
		String newTaskDateString = sdf.format(newTask.getEndDate().getTime());
		return checkIsOverloaded(limit, newTaskDateString);
	}

	private static boolean checkIsOverloaded(int limit, String newDeadlineDate) {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy");
		boolean isNewDeadlineDateInToDoList = true;
		boolean hasHitLimit = false;
		int limitCount = 0;
		String currentDate = null;
		Iterator<Task> taskListIter = toDoList.iterator();

		while (taskListIter.hasNext()) {
			Task t = taskListIter.next();
			// dont count floating tasks and events
			if (!t.isDeadline()) {
				continue;
			}

			String deadlineDate = sdf.format(t.getEndDate().getTime());

			// adds to count if the task's date is the same as the current date
			// otherwise reset count and update current date
			if (deadlineDate.equals(currentDate)) {
				limitCount += 1;
			} else {
				currentDate = deadlineDate;
				limitCount = 1;
			}
			if (isNewDeadlineDateInToDoList) {
				if (deadlineDate.equals(newDeadlineDate)) {
					limitCount += 1;
					isNewDeadlineDateInToDoList = false;
				}
			}
			if (limitCount > limit) {
				hasHitLimit = true;
				break;
			}
		}
		return hasHitLimit;
	}

	public String edit(int taskID, ProtoTask toEditTask) throws OverloadException, InvalidDateException {
		if (toDoList.contains(taskID)) {
			Task newTask = new Task(toEditTask);
			Task.decrementGlobalId();
			if (isOverloaded(newTask)) {
				throw new StorageExceptions.OverloadException(pf.getOverloadLimit());
			}
			//method changes TaskLists, hence use state to save the old versions
			state.prepareForUndo(toDoList, doneList);
			toDoList.edit(taskID, toEditTask);
			String editedTaskDetails = toDoList.displayID(taskID);
			return String.format(RETURN_MESSAGE_FOR_EDIT, editedTaskDetails);
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}

	public String complete(int taskID) {
		if (toDoList.contains(taskID)) {
			//method changes TaskLists, hence use state to save the old versions
			state.prepareForUndo(toDoList, doneList);
			Task completedTask = toDoList.delete(taskID);
			completedTask.setQueueID(-(doneList.size() + 1));
			if (queueList.contains(taskID)) {
				queueList.delete(taskID);
				updateQueueIDs(0, 0);
			}
			doneList.add(completedTask);
			return String.format(RETURN_MESSAGE_FOR_COMPLETE, completedTask.displayAll());
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}

	public String uncomplete(int taskID) {
		if (doneList.contains(taskID)) {
			//method changes TaskLists, hence use state to save the old versions
			state.prepareForUndo(toDoList, doneList);
			Task uncompletedTask = doneList.delete(taskID);
			uncompletedTask.setQueueID(-1);
			toDoList.add(uncompletedTask);
			return String.format(RETURN_MESSAGE_FOR_UNCOMPLETE, uncompletedTask.displayAll());
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID_DONELIST, taskID);
		}
	}

	public String delete(int taskID) {
		if (toDoList.contains(taskID)) {
			//method changes TaskLists, hence use state to save the old versions
			state.prepareForUndo(toDoList, doneList);
			Task deletedTask = toDoList.delete(taskID);
			if (queueList.contains(taskID)) {
				queueList.delete(taskID);
				updateQueueIDs(0, 0);
			}
			return String.format(RETURN_MESSAGE_FOR_DELETE, deletedTask.displayAll());
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}

	public String displayID(int taskID) {
		if (toDoList.contains(taskID)) {
			return toDoList.displayID(taskID);
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}

	public String display(ProtoTask pt, String tl) {
		TaskList taskList;
		if (tl.equals("toDoList")) {
			taskList = toDoList;
		} else {
			taskList = doneList;
		}
		if (pt.getSearchKey() != null) {
			taskList.sort(null, true);
			return taskList.search(pt.getSearchKey());
		}

		if (pt.getId() != -1) {
			return displayID(pt.getId());
		} else {
			String sortBy = pt.getSortCrit();
			assert sortBy.equals("@") || sortBy.equals("!") || sortBy.equals("#") || sortBy.equals("$")
					|| sortBy.equals("&") || sortBy.equals("+") || sortBy == null;
			boolean isAscending = pt.getIsAscending();
			taskList.sort(sortBy, isAscending);
			if (sortBy == null) {
				return taskList.displayDefault(defaultNumberOfDisplayedTasks);
			} else {
				return taskList.display(defaultNumberOfDisplayedTasks);
			}
		}
	}

	public String queue(int taskID, int pos) {
		if (toDoList.contains(taskID)) {
			//method changes TaskLists, hence use state to save the old versions
			state.prepareForUndo(toDoList, doneList);
			boolean isPosDefault = pos == -1;
			boolean isPosTooLarge = pos > queueList.size();
			boolean isBackOfQueue = isPosDefault || isPosTooLarge;
			Task qTask = toDoList.get(taskID);
			if (isBackOfQueue) {
				pos = queueList.size();
			}
			if (queueList.contains(taskID)) {

				queueList.delete(taskID);
				queueList.add(pos - 1, qTask);

			} else {
				if (isBackOfQueue) {
					queueList.add(pos, qTask);
				} else {
					queueList.add(pos - 1, qTask);
				}
			}

			pos = updateQueueIDs(taskID, pos);

			return String.format(RETURN_MESSAGE_FOR_QUEUE, qTask.displayAll(), pos);
		} else {
			return String.format(RETURN_MESSAGE_FOR_NONEXISTENT_ID, taskID);
		}
	}

	private int updateQueueIDs(int taskID, int pos) {
		Iterator<Task> qIter = queueList.iterator();
		int count = 1;
		while (qIter.hasNext()) {
			Task t = qIter.next();
			t.setQueueID(count);
			if (t.getId() == taskID) {
				pos = t.getQueueID();
			}
			count++;
		}
		return pos;
	}

	public String setLimit(int limit) {
		assert limit >= 0;
		pf.setOverloadLimit(limit);
		if (limit == 0) {
			pf.setOverloadLimit(-1);
			return RETURN_MESSAGE_FOR_SETLIMIT_OFF;
		} else if (checkIsOverloaded(limit, null)) {
			return String.format(RETURN_MESSAGE_FOR_SETLIMIT_WHEN_ABOVE_LIMIT, limit);
		} else {
			return String.format(RETURN_MESSAGE_FOR_SETLIMIT, limit);
		}
	}

```
###### \src\tucklife\storage\internal\Storage.java
``` java
	//for testing purposes only
	public static void clear() {
		Task.resetGlobalId();
		pf = new PrefsStorage();
		pf.setOverloadLimit(-1);
		toDoList = new TaskList();
		queueList = new TaskList();
		doneList = new TaskList();
		state = new SaveState();
	}

	public static TaskList getTD() {
		return toDoList;
	}

	public static TaskList getQ() {
		return queueList;
	}
}
```
###### \src\tucklife\storage\internal\StorageExceptions.java
``` java
package tucklife.storage.internal;

import java.text.SimpleDateFormat;
import java.util.Calendar;

//Nested class of all exceptions that are returned to Flow Controller
public class StorageExceptions {

	//Returned when the number of tasks in a day exceeds the limit
	public static class OverloadException extends Exception {
		private int limit;
		private static final String RETURN_MESSAGE_FOR_OVERLOAD = "That day has been filled with %1$s tasks! It hit the limit! You should reschedule the task to another day. "
				+ "Alternatively, you can either change the overload limit or turn it off.";

		public OverloadException(int limit) {
			this.limit = limit;
		}

		public String getReturnMsg() {
			return String.format(RETURN_MESSAGE_FOR_OVERLOAD, this.limit);
		}
	}
	
	public static class NothingToUndoException extends Exception {
		private static final String RETURN_MESSAGE_FOR_NOTHING_TO_UNDO = "There is no previous action to undo!";

		public String getReturnMsg() {
			return RETURN_MESSAGE_FOR_NOTHING_TO_UNDO;
		}
	}

	public static class NothingToRedoException extends Exception {
		private static final String RETURN_MESSAGE_FOR_NOTHING_TO_REDO = "There is no previous action to redo!";

		public String getReturnMsg() {
			return RETURN_MESSAGE_FOR_NOTHING_TO_REDO;
		}
	}

	//Returned when start date is before end date
	public static class InvalidDateException extends Exception {

		private SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy HH:mm");
		Calendar start;
		Calendar end;
		Calendar deadline;

		public InvalidDateException(Calendar start, Calendar end) {
			this.start = start;
			this.end = end;
		}

		public InvalidDateException(Calendar start, Calendar end, Calendar deadline) {
			this.start = start;
			this.end = end;
			this.deadline = deadline;
		}

		public String getReturnMsg() {
			String startDate = sdf.format(start.getTime());
			String endDate = sdf.format(end.getTime());
			if (this.deadline == null) {
				return startDate + " is before " + endDate + "!";
			} else {
				String deadlineDate = sdf.format(deadline.getTime());
				return "Task is currently an event from " + startDate + " to " + endDate
						+ ", unable to change it to a deadline by " + deadlineDate + "!";
			}
		}
	}

}
```
###### \src\tucklife\storage\internal\StorageTest.java
``` java
package tucklife.storage.internal;

import static org.junit.Assert.*;

import java.util.Hashtable;

import org.junit.Before;
import org.junit.Test;

import tucklife.UI.FlowController;
import tucklife.parser.Parser;
import tucklife.storage.Task;
import tucklife.storage.TaskList;

public class StorageTest {

	Parser p;
	FlowController fc;
	Storage s;
	String status;

	@Before
	public void setUp() throws Exception {
		p = new Parser();
		fc = new FlowController();
		Hashtable<String, String> ht = new Hashtable<String, String>();
		p.loadCommands(ht);
	}

	@Test
	public void testSortLocation() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @as4-mr3";
		String command2 = "add staff retreat @sentosa";
		String command3 = "add interview intern";

		String command4 = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);

		status = s.getStatus() + "\n\n";
		assertEquals("not sorted", status + "3. interview in...\n1. meeting        \n2. staff retreat  \n",
				fc.execute(command4));

		String command5 = "display +@";

		status = s.getStatus() + "\n\n";
		assertEquals("sorted ascending", status + "1. meeting        \n2. staff retreat  \n3. interview in...\n",
				fc.execute(command5));

		String command6 = "display -@";

		status = s.getStatus() + "\n\n";
		assertEquals("sorted descending", status + "3. interview in...\n2. staff retreat  \n1. meeting        \n",
				fc.execute(command6));
	}

	@Test
	public void testOverloadAdd() {
		Storage.clear();

		String command1 = "add meeting @meeting room 7 $16/05 +1400";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $16/05 +1300";

		String command4 = "setlimit 4";

		String command5 = "add 4th task $16/05 +2359";
		String command6 = "add overload $16/05 +2300";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);

		TaskList td = Storage.getTD();
		assertEquals("able to add", 4, td.size());

		fc.execute(command6);
		td = Storage.getTD();
		assertEquals("unable to add", 4, td.size());
	}

	@Test
	public void testOverloadEdit() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @meeting room 7 $16/05 +1400";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $16/05 +1300";

		String command4 = "setlimit 4";

		String command5 = "add 4th task $16/05 +2359";
		String command6 = "add overload $17/05 +2300";
		String command7 = "edit 5 $16/05";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);

		TaskList td = Storage.getTD();
		assertEquals("able to add", 4, td.size());

		fc.execute(command6);
		td = Storage.getTD();
		assertEquals("able to add", 5, td.size());

		fc.execute(command7);
		td = Storage.getTD();
		assertEquals("unable to add", 5, td.size());

	}

	@Test
	public void testOverloadMultipleAdds() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @meeting room 7 $16/05 +1400";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $16/05 +1300";

		String command4 = "setlimit 4";

		String command5 = "add 4th task $16/05 +2359";
		String command6 = "add redundant $17/05 +2300";
		String command7 = "add overload $16/05 +2300";

		String command8 = "add safety awareness week $09/05 to 16/05 #gg";
		String command9 = "add holiday $10/05 to 16/05 &to siam stupid stuff";
		String command10 = "add meeting $16/05 +2pm to 3pm";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);

		fc.execute(command9);
		fc.execute(command5);

		TaskList td = Storage.getTD();
		assertEquals("able to add", 5, td.size());

		fc.execute(command6);
		td = Storage.getTD();
		assertEquals("able to add", 6, td.size());

		fc.execute(command7);
		td = Storage.getTD();
		assertEquals("unable to add", 6, td.size());

		fc.execute(command8);
		td = Storage.getTD();
		assertEquals("able to add", 7, td.size());

		fc.execute(command10);
		td = Storage.getTD();
		assertEquals("able to add", 8, td.size());
	}

	@Test
	public void testSearch() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500 &meet at 4am";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16 &buy teammeet beer";
		String command7 = "add email boss $15/05 #siammeeting";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		assertEquals("added correctly", 7, td.size());

		String search = "display meeting";
		fc.execute(search);
		status = s.getStatus() + "\n\n";
		assertEquals("search correctly",
				status + "Exact Match"
						+ "\n5. client meeting | By: Mon, 09 May 2016 23:59"
						+ "\n1. meeting | Location: meeting room 7"
						+ "\n\nPartial Match"
						+ "\n7. email boss | By: Sun, 15 May 2016 23:59 | Category: siammeeting\n",
				fc.execute(search));
	}

	@Test
	public void testSearchPartial() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500 &meet at 4am";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16 &buy teammeet beer";
		String command7 = "add email boss $15/05 #siammeeting";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		assertEquals("added correctly", 7, td.size());

		String search = "display meet";
		fc.execute(search);
		status = s.getStatus() + "\n\n";
		assertEquals("search correctly",
				status + "Exact Match"
						+ "\n2. staff retreat | By: Mon, 16 May 2016 05:00 | Location: botanic gardens | Additional: meet at 4am"
						+ "\n\nPartial Match"
						+ "\n6. payday | By: Thu, 05 May 2016 23:59 | Additional: buy teammeet beer"
						+ "\n5. client meeting | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss | By: Sun, 15 May 2016 23:59 | Category: siammeeting"
						+ "\n1. meeting | Location: meeting room 7\n",
				fc.execute(search));
	}

	@Test
	public void testUncomplete() {
		Storage.clear();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500 &Meet at 4am";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client Meeting $09/05/16";
		String command6 = "add payday $05/05/16 &buy teammeet beer";
		String command7 = "add email boss $15/05 #siammeeting";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);
		td = Storage.getTD();
		assertEquals("added correctly", 7, td.size());

		String complete = "complete 4";
		fc.execute(complete);

		td = Storage.getTD();
		assertEquals("uncompelete correctly", 6, td.size());

		String uncomplete = "uncomplete 4";
		fc.execute(uncomplete);
		td = Storage.getTD();
		assertEquals("uncompelete correctly", 7, td.size());
	}

	@Test
	public void testUndo() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";

		String commandDisplay = "display ++";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		status = s.getStatus() + "\n\n";
		assertEquals("check display",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));
		String command5 = "undo";
		fc.execute(command5);
		status = s.getStatus() + "\n\n";
		assertEquals("check display change",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));
	}

	@Test
	public void testNonConsecutiveUndos() {
		Storage.clear();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		assertEquals("added correctly", 7, td.size());

		String undo = "undo";
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to handle non-consecutive undos", 8, td.size());
	}

	@Test
	public void testMultipleConsecutiveUndos() {
		Storage.clear();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		assertEquals("added correctly", 7, td.size());

		String undo = "undo";
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 5, td.size());
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 4, td.size());
	}

	@Test
	public void testUndoForQueue() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);

		status = s.getStatus() + "\n\n";
		assertEquals("check display",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));
		String command4 = "queue 1";
		fc.execute(command4);
		status = s.getStatus() + "\n\n";
		assertEquals("task is queued",
				status + "Queue:"
						+ "\n1. meeting        "
						+ "\n\nOther Tasks:"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59\n",
				fc.execute(commandDisplay));
		String command5 = "undo";
		fc.execute(command5);
		status = s.getStatus() + "\n\n";
		assertEquals("task is unqueued",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));
	}

	@Test
	public void testRedo() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";

		String commandDisplay = "display ++";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		status = s.getStatus() + "\n\n";
		assertEquals("check display",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String commandDO = "undo";
		fc.execute(commandDO);
		status = s.getStatus() + "\n\n";
		assertEquals("check display change",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		commandDO = "redo";
		fc.execute(commandDO);
		status = s.getStatus() + "\n\n";
		assertEquals("check display",
				status + "2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

	}

	@Test
	public void testMultipleRedo() {
		Storage.clear();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		assertEquals("added correctly", 7, td.size());

		String undo = "undo";
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 5, td.size());
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 4, td.size());
		String redo = "redo";
		fc.execute(redo);
		td = Storage.getTD();
		assertEquals("able to undo once", 5, td.size());
		fc.execute(redo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 6, td.size());
		fc.execute(redo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 7, td.size());
	}

	@Test
	public void testRedoAfterNonUndo() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		assertEquals("added correctly", 7, td.size());

		String undo = "undo";
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo once", 6, td.size());
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 5, td.size());
		fc.execute(undo);
		td = Storage.getTD();
		assertEquals("able to undo multiple times", 4, td.size());
		fc.execute(command5);
		String redo = "redo";
		status = s.getStatus() + "\n\n";
		assertEquals("previous command not undo", status + "There is no previous action to redo!", fc.execute(redo));
	}

	@Test
	public void testAddToBackOfQueue() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();
		Task t;

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		fc.execute(command8);
		fc.execute(command9);
		fc.execute(command10);
		t = td.get(5);
		assertEquals("task is added to back of queue", 3, t.getQueueID());
	}

	@Test
	public void testQueueIDUpdated() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();
		Task t;

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		String command11 = "queue 7 1";
		fc.execute(command8);
		t = td.get(4);
		assertEquals("queue id is updated", 1, t.getQueueID());
		fc.execute(command9);
		fc.execute(command10);
		fc.execute(command11);
		assertEquals("queue id is updated", 2, t.getQueueID());
	}

```
###### \src\tucklife\storage\internal\StorageTest.java
``` java
	@Test
	public void testQueueIDAfterDeletion() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();
		Task t;

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		String command11 = "queue 7 1";
		String command12 = "queue 2 4";
		String command13 = "queue 1 100";
		fc.execute(command8);
		fc.execute(command9);
		fc.execute(command10);
		fc.execute(command11);
		fc.execute(command12);
		fc.execute(command13);
		String command14 = "delete 2";
		fc.execute(command14);
		t = td.get(5);
		assertEquals("queue id is updated after deletion", 4, t.getQueueID());
	}

	@Test
	public void testQueueIDAfterCompletion() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();
		Task t;

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		String command11 = "queue 7 1";
		String command12 = "queue 2 4";
		String command13 = "queue 1 100";
		fc.execute(command8);
		fc.execute(command9);
		fc.execute(command10);
		fc.execute(command11);
		fc.execute(command12);
		fc.execute(command13);
		String command14 = "complete 2";
		fc.execute(command14);
		t = td.get(5);
		assertEquals("queue id is updated after completion", 4, t.getQueueID());
	}

	@Test
	public void testCompletedTaskQueueID() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();
		Task t;

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		String command11 = "queue 7 1";
		String command12 = "queue 2 4";
		String command13 = "queue 1 100";
		fc.execute(command8);
		fc.execute(command9);
		fc.execute(command10);
		fc.execute(command11);
		fc.execute(command12);
		fc.execute(command13);
		String command14 = "complete 2";
		fc.execute(command14);
		t = td.get(6);
		String command15 = "complete 6";
		fc.execute(command15);
		assertEquals("queue id of completed is updated to default", -2, t.getQueueID());
	}

	@Test
	public void testQueueDisplay() {
		Storage.clear();
		s = FlowController.getStorage();

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		String command11 = "queue 7 1";
		String command12 = "queue 2 4";
		String command13 = "queue 1 100";
		fc.execute(command8);
		fc.execute(command9);
		fc.execute(command10);
		fc.execute(command11);
		fc.execute(command12);
		fc.execute(command13);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "Queue:\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n1. meeting        "
						+ "\n\nOther Tasks:"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59\n",
				fc.execute(commandDisplay));
	}

	@Test
	public void testQueueWithUndo() {
		Storage.clear();
		s = FlowController.getStorage();

		TaskList td = Storage.getTD();
		Task t;

		String command1 = "add meeting @meeting room 7";
		String command2 = "add staff retreat @botanic gardens $16/05 +0500";
		String command3 = "add interview intern @mr5 $13/12/16";
		String command4 = "add financial report $01/05/16";
		String command5 = "add client meeting $09/05/16";
		String command6 = "add payday $05/05/16";
		String command7 = "add email boss $15/05";

		String commandDisplay = "display";

		fc.execute(command1);
		fc.execute(command2);
		fc.execute(command3);
		fc.execute(command4);
		fc.execute(command5);
		fc.execute(command6);
		fc.execute(command7);

		status = s.getStatus() + "\n\n";
		assertEquals("check normal display without queue",
				status + "4. financial re... | By: Sun, 01 May 2016 23:59"
						+ "\n6. payday          | By: Thu, 05 May 2016 23:59"
						+ "\n5. client meeting  | By: Mon, 09 May 2016 23:59"
						+ "\n7. email boss      | By: Sun, 15 May 2016 23:59"
						+ "\n2. staff retreat   | By: Mon, 16 May 2016 05:00"
						+ "\n3. interview in... | By: Tue, 13 Dec 2016 23:59"
						+ "\n1. meeting        \n",
				fc.execute(commandDisplay));

		String command8 = "queue 4";
		String command9 = "queue 6";
		String command10 = "queue 5";
		String command11 = "queue 7 1";
		String command12 = "queue 2 2";
		String commandUndo = "undo";
		fc.execute(command8);
		fc.execute(command9);
		fc.execute(command10);
		fc.execute(command11);
		fc.execute(command12);
		t = td.get(4);
		assertEquals("correct id", 3, t.getQueueID());
		fc.execute(commandUndo);
		td = Storage.getTD();
		t = td.get(6);
		assertEquals("correct id", 3, t.getQueueID());
	}

}
```
###### \src\tucklife\storage\Task.java
``` java
package tucklife.storage;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;
import tucklife.storage.internal.Storage;
import tucklife.storage.internal.StorageExceptions;
import tucklife.storage.internal.StorageExceptions.InvalidDateException;

public class Task {

	private static final Logger log = Logger.getLogger(Storage.class.getName());

	private String location;
	private int priority;
	private String category;
	private String additional;
	private String name;

	// if null, means that it is a task not event
	private Calendar startDate;

	// either deadline or end time for event. if null, means it is a floating task
	
	private Calendar endDate;

	private boolean floating;
	private boolean deadline;

	private static int globalID = 1;

	private int id;

	private int queueID;

	private static final String HEADER_LOCATION = "Location: ";
	private static final String HEADER_CATEGORY = "Category: ";
	private static final String HEADER_PRIORITY = "Priority: ";
	private static final String HEADER_DEADLINE = "By: ";
	private static final String HEADER_ADDITIONAL = "Additional: ";
	private static final String HEADER_EVENT_START = "From: ";
	private static final String HEADER_EVENT_END = " To: ";

	private static final String PRIORITY_HIGH = "High";
	private static final String PRIORITY_MEDIUM = "Med";
	private static final String PRIORITY_LOW = "Low";

	private static final String TASK_NAME_EXTENDER = "...";
	private static final String TASK_FIELD_SEPERATOR = " | ";

	public static void resetGlobalId() {
		globalID = 1;
	}

	// used when Task is created but not added into TaskList
	public static void decrementGlobalId() {
		globalID = globalID - 1;
	}

	public int getId() {
		return id;
	}

	public String getLocation() {
		return location;
	}

	public int getPriority() {
		return priority;
	}

	public String getCategory() {
		return category;
	}

	public String getAdditional() {
		return additional;
	}

	public String getName() {
		return name;
	}

	public Calendar getStartDate() {
		return startDate;
	}

	public Calendar getEndDate() {
		return endDate;
	}

	public boolean isFloating() {
		return floating;
	}

	public static int getGlobalID() {
		return globalID;
	}

	public int getQueueID() {
		return queueID;
	}

	public boolean isDeadline() {
		return deadline;
	}

	public String getterForVariables() {
		return "";
	}

	public void setQueueID(int id) {
		this.queueID = id;
	}

	public Task(ProtoTask task) throws InvalidDateException {
		// create the Task
		this.location = task.getLocation();
		this.priority = task.getPriority();
		this.category = task.getCategory();
		this.additional = task.getAdditional();
		this.name = task.getTaskDesc();
		this.startDate = task.getStartDate();
		this.endDate = task.getEndDate();
		checkValidDates(startDate, endDate);
		this.floating = startDate == null && endDate == null;
		this.deadline = !this.floating && this.startDate == null;
		this.id = globalID;
		this.queueID = task.getPosition();
		globalID++;
		log.log(Level.FINE, "Task has been created via ProtoTask");
	}

	public Task(Task task) {
		// create the Task
		this.location = task.getLocation();
		this.priority = task.getPriority();
		this.category = task.getCategory();
		this.additional = task.getAdditional();
		this.name = task.getName();
		this.startDate = task.getStartDate();
		this.endDate = task.getEndDate();
		this.floating = startDate == null && endDate == null;
		this.deadline = this.floating || this.startDate == null;
		this.id = task.getId();
		this.queueID = task.getQueueID();
	}

	public Task edit(ProtoTask task) throws InvalidDateException {
		// edit task
		this.location = editParam(this.location, task.getLocation());
		this.priority = editParam(this.priority, task.getPriority());
		this.category = editParam(this.category, task.getCategory());
		this.additional = editParam(this.additional, task.getAdditional());
		this.name = editParam(this.name, task.getTaskDesc());

		editDate(task);

		this.floating = startDate == null && endDate == null;
		this.deadline = this.floating || this.startDate == null;
		this.id = task.getId() == -1 ? this.id : task.getId();
		log.log(Level.FINE, "Task has been edited via ProtoTask");
		return this;
	}

	private void editDate(ProtoTask task) throws InvalidDateException {
		preEditEndDate(task);

		preEditStartDate(task);

		boolean editHasNoDate = task.getStartDate() == null && task.getEndDate() == null;

		// only do such changes if there is a time but no date
		if (editHasNoDate) {
			// task to change into is a deadline
			if (task.getStartTime() == null && task.getEndTime() != null) {
				// if current task is a floating task
				if (this.endDate == null) {
					// take deadline to be nearest time, similar to the way add
					// handles a single time
					this.endDate = task.getEndTime();
				} else {
					// change the time of the deadline
					this.endDate = mergeDateTime(this.endDate, task.getEndTime());
				}
			}
			// task to change into is an event
			if (task.getStartTime() != null && task.getEndTime() != null) {
				// if current task is already a multiday event, just need to
				// merge
				if (this.startDate != null && this.startDate != this.endDate) {
					this.startDate = mergeDateTime(this.startDate, task.getStartTime());
					this.endDate = mergeDateTime(this.endDate, task.getEndTime());
				} else {
					// change current task into a single day event
					if (onSameDay(task.getStartTime(), task.getEndTime())) {
						this.startDate = mergeDateTime(this.endDate, task.getStartTime());
						this.endDate = mergeDateTime(this.endDate, task.getEndTime());
					} else {
						// timing does not fall within a single day
						this.startDate = mergeDateTime(this.endDate, task.getStartTime());
						this.endDate = mergeDateTime(tomorrow(this.endDate), task.getEndTime());
					}
				}

				// change floating task to event
				if (isFloating()) {
					this.startDate = task.getStartTime();
					this.endDate = task.getEndTime();
				}
			}
		}

		checkValidDates(startDate, endDate);

		boolean removeDateParam = task.getEndDate() != null && task.getEndDate().get(Calendar.YEAR) == 2000;
		if (removeDateParam) {
			this.startDate = null;
			this.endDate = null;
		}
	}

	private void preEditStartDate(ProtoTask task) {
		// need to merge if there is only date but no time
		if (task.getStartTime() == null && task.getStartDate() != null) {
			this.startDate = mergeDateTime(task.getStartDate(), this.startDate);
		} else {
			// no need to merge, can get the start date directly
			if (task.getStartTime() != null && task.getStartDate() != null) {
				this.startDate = task.getStartDate();
			}
			// since there is no start date and time given, set startdate to
			// null
			if (task.getStartTime() == null && task.getStartDate() == null) {
				this.startDate = null;
			}
		}
	}

	private void preEditEndDate(ProtoTask task) {
		// need to merge if there is only date but no time
		if (task.getEndTime() == null && task.getEndDate() != null) {
			this.endDate = mergeDateTime(task.getEndDate(), this.endDate);
			// no need to merge, can get the end date directly
			if (task.getStartDate() == null && this.startDate != null) {
				this.endDate = task.getEndDate();
			}
		} else {
			// no need to merge, can get the end date directly
			if (task.getEndTime() != null && task.getEndDate() != null) {
				this.endDate = task.getEndDate();
			}
		}
	}
	
	private String editParam(String self, String change) {
		//check if ProtoTask demands a change to the Task
		if (change != null) {
			//check if the parameter should be removed
			if (change.equals("")) {
				return null;
			} else {
				return change;
			}
		} else {
			return self;
		}
	}

	private int editParam(int self, int change) {
		//check if ProtoTask demands a change to the Task
		if (change != -1) {
			//check if the parameter should be removed
			if (change == 0) {
				return 0;
			} else {
				return change;
			}
		} else {
			return self;
		}
	}

	private Calendar tomorrow(Calendar endDate) {
		if (endDate == null) {
			return null;
		}
		endDate.add(Calendar.DATE, 1);
		return endDate;
	}

	private boolean onSameDay(Calendar startTime, Calendar endTime) {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy");
		return sdf.format(startTime.getTime()).equals(sdf.format(endTime.getTime()));
	}

	public String display() {
		StringBuilder displayString = new StringBuilder();

		// display order:
		// id. truncated name | date

		displayString.append(idField());
		displayString.append(" ");
		displayString.append(nameField(true));
		
		String date = dateField();

		if(date != null){
			displayString.append(TASK_FIELD_SEPERATOR);
			displayString.append(date);
		}

		return displayString.toString();
	}

	public boolean containsExact(String searchKey) {
		String[] fields = new String[6];

		fields[0] = dateField();
		fields[1] = locationField();
		fields[2] = priorityField();
		fields[3] = categoryField();
		fields[4] = additionalField();
		fields[5] = getName();
		
		String searchItem = " " + searchKey + " ";

		for (int i = 0; i < 6; i++) {
			if (fields[i] != null) {
				String searchFrom = "  " + fields[i] + " ";
				if (searchFrom.toLowerCase().contains(searchItem.toLowerCase())) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean containsPartial(String searchKey) {
		if (this.containsExact(searchKey)) {
			return false;
		}
		String[] fields = new String[6];

		fields[0] = dateField();
		fields[1] = locationField();
		fields[2] = priorityField();
		fields[3] = categoryField();
		fields[4] = additionalField();
		fields[5] = getName();

		for (int i = 0; i < 6; i++) {
			if (fields[i] != null) {
				if (fields[i].toLowerCase().contains(searchKey.toLowerCase())) {
					return true;
				}
			}
		}
		return false;
	}

	private String idField() {
		String rawId = Integer.toString(id);
		int padSize = Integer.toString(globalID).length();

		String paddedId = String.format("%" + Integer.toString(padSize) + "s", rawId);

		return paddedId + ".";
	}

	private String nameField(boolean truncated) {
		if (truncated) {
			// truncates long names
			if (name.length() > 15) {
				return name.substring(0, 12) + TASK_NAME_EXTENDER;
			} else {
				return String.format("%-15s", name);
			}
		}

		return name;
	}

	private String dateField() {
		SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
		if (endDate == null) {
			return null;

		} else if (endDate != null && startDate == null) {
			return HEADER_DEADLINE + sdf.format(endDate.getTime());

		} else if (endDate != null && startDate != null) {
			return HEADER_EVENT_START + sdf.format(startDate.getTime()) + HEADER_EVENT_END
					+ sdf.format(endDate.getTime());
		}

		// shouldn't happen if task is correct
		return null;
	}

	private String locationField() {
		if (location == null) {
			return null;
		} else {
			return HEADER_LOCATION + location;
		}
	}

	private String priorityField() {
		if (priority == -1) {
			return null;
		} else {
			switch (priority) {
			case 1:
				return HEADER_PRIORITY + PRIORITY_HIGH;
			case 2:
				return HEADER_PRIORITY + PRIORITY_MEDIUM;
			case 3:
				return HEADER_PRIORITY + PRIORITY_LOW;

			// shouldn't happen if task is correct
			default:
				return null;
			}
		}
	}

	private String categoryField() {
		if (category == null) {
			return null;
		} else {
			return HEADER_CATEGORY + category;
		}
	}

	private String additionalField() {
		if (additional == null) {
			return null;
		} else {
			return HEADER_ADDITIONAL + additional;
		}
	}

	public String displayAll() {
		StringBuilder fullDisplayString = new StringBuilder();

		// displayAll order:
		// id. full name | date | location | priority | category | additional

		fullDisplayString.append(idField());
		fullDisplayString.append(" ");
		fullDisplayString.append(nameField(false));

		String[] fields = new String[5];

		fields[0] = dateField();
		fields[1] = locationField();
		fields[2] = priorityField();
		fields[3] = categoryField();
		fields[4] = additionalField();

		for (int i = 0; i < 5; i++) {
			if (fields[i] != null) {
				fullDisplayString.append(TASK_FIELD_SEPERATOR);
				fullDisplayString.append(fields[i]);
			}
		}

		return fullDisplayString.toString();
	}

```
###### \src\tucklife\storage\Task.java
``` java
	private Calendar mergeDateTime(Calendar date, Calendar time) {
		if (date == null) {
			return null;
		}
		Calendar c = Calendar.getInstance();

		c.set(Calendar.YEAR, date.get(Calendar.YEAR));
		c.set(Calendar.MONTH, date.get(Calendar.MONTH));
		c.set(Calendar.DATE, date.get(Calendar.DATE));
		if (time == null) {
			c.set(Calendar.HOUR_OF_DAY, date.get(Calendar.HOUR_OF_DAY));
			c.set(Calendar.MINUTE, date.get(Calendar.MINUTE));
		} else {
			c.set(Calendar.HOUR_OF_DAY, time.get(Calendar.HOUR_OF_DAY));
			c.set(Calendar.MINUTE, time.get(Calendar.MINUTE));
		}

		return c;
	}

	private void checkValidDates(Calendar start, Calendar end) throws InvalidDateException {
		if (end == null) {
			return;
		}
		if (end.before(start) && start != null) {
			throw new StorageExceptions.InvalidDateException(start, end);
		}
	}

}
```
###### \src\tucklife\storage\TaskComparators.java
``` java
package tucklife.storage;

import java.util.Comparator;
import java.util.Calendar;

public class TaskComparators {

	//Handles the event where the parameters to compare are null
	private static int handleNullCases(Task task1, Task task2, String param1, String param2) {
		if (param1 == null && param2 == null) {
			return new ComparatorName().compare(task1, task2);
		} else {
			if (param1 == null) {
				return 1;
			}
			if (param2 == null) {
				return -1;
			}
			//If the comparisons are equivalent, compare by name
			if (param1.compareTo(param2) == 0) {
				return new ComparatorName().compare(task1, task2);
			}
		}
		return param1.compareTo(param2);
	}

	public static class ComparatorLocation implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			String location1 = t1.getLocation();
			String location2 = t2.getLocation();
			return handleNullCases(t1, t2, location1, location2);
		}
	}

	public static class ComparatorPriority implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			int priority1 = t1.getPriority();
			int priority2 = t2.getPriority();

			if (priority1 - priority2 == 0) {
				return new ComparatorName().compare(t1, t2);
			} else {
				return priority1 - priority2;
			}
		}
	}

	public static class ComparatorCategory implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			String cat1 = t1.getCategory();
			String cat2 = t2.getCategory();
			return handleNullCases(t1, t2, cat1, cat2);
		}
	}

	public static class ComparatorAdditional implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			String add1 = t1.getAdditional();
			String add2 = t2.getAdditional();

			return handleNullCases(t1, t2, add1, add2);
		}
	}

	public static class ComparatorName implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			String name1 = t1.getName();
			String name2 = t2.getName();

			return name1.compareTo(name2);
		}
	}

	public static class ComparatorDefault implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			int qid1 = t1.getQueueID();
			int qid2 = t2.getQueueID();
			if (qid1 == qid2) {
				return new ComparatorTime().compare(t1, t2);
			} else {
				if (qid1 == -1) {
					return -qid1;
				}

				if (qid2 == -1) {
					return qid2;
				}
				return qid1 - qid2;
			}
		}
	}
	
	//Compares the start times if they exist, else compare the end times
	public static class ComparatorTime implements Comparator<Task> {

		@Override
		public int compare(Task t1, Task t2) {
			Calendar sd1 = t1.getStartDate();
			Calendar sd2 = t2.getStartDate();
			Calendar ed1 = t1.getEndDate();
			Calendar ed2 = t2.getEndDate();

			Calendar d1;
			Calendar d2;

			if (sd1 == null) {
				d1 = ed1;
			} else {
				d1 = sd1;
			}

			if (sd2 == null) {
				d2 = ed2;
			} else {
				d2 = sd2;
			}

			if (t1.isFloating() && t2.isFloating()) {
				return new ComparatorPriority().compare(t1, t2);
			} else {
				if (d1 == null) {
					return 1;
				}
				if (d2 == null) {
					return -1;
				}
				return d1.compareTo(d2);
			}
		}
	}
}
```
###### \src\tucklife\storage\TaskList.java
``` java
package tucklife.storage;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;
import tucklife.storage.internal.Storage;
import tucklife.storage.internal.StorageExceptions.InvalidDateException;

public class TaskList {

	private static final Logger log = Logger.getLogger(Storage.class.getName());

	private ArrayList<Task> taskList;

	public TaskList() {
		taskList = new ArrayList<Task>();
	}

	public boolean contains(int taskID) {
		boolean containsID = false;
		for (Task task : taskList) {
			if (hasFoundID(taskID, task)) {
				containsID = true;
			}
		}
		return containsID;
	}

	// precondition: there must be a task with taskID in the ArrayList
	public String displayID(int taskID) {
		String displayString = "";
		for (Task task : taskList) {
			if (hasFoundID(taskID, task)) {
				displayString = task.displayAll();
			}
		}
		return displayString;
	}

	public String display(int itemsToDisplay) {
		StringBuilder sb = new StringBuilder();
		int i;
		boolean flag = true;
		if (taskList.size() <= itemsToDisplay) {
			itemsToDisplay = taskList.size();
			flag = false;
		}
		for (i = 0; i < itemsToDisplay; i++) {
			Task task = taskList.get(i);
			sb.append(task.display());
			sb.append("\n");
		}
		if (flag) {
			int remaining = taskList.size() - i;
			sb = getRemainingString(sb, remaining, "And %1$s other task\n", "And %1$s other tasks\n");
		}
		return sb.toString();
	}

	public String displayDefault(int itemsToDisplay) {
		if (taskList.size() == 0) {
			return "No tasks to display!";
		}
		StringBuilder sb = new StringBuilder();

		int qCounter = 0;
		for (Task qTask : taskList) {
			if (qTask.getQueueID() > 0) {
				qCounter += 1;
			}
		}
		int rCounter = taskList.size() - qCounter;

		int queueItemsToDisplay = itemsToDisplay / 2;
		int counter = 0;
		Task task = taskList.get(0);

		// Only add the "Queue:\n" and "\nOther Tasks:\n" headers if there are queued Task
		if (task.getQueueID() > 0) {
			counter = displayQueuedTasks(sb, qCounter, queueItemsToDisplay, counter);
			displayOtherTasks(itemsToDisplay, sb, rCounter, counter);
		} else {
			// Since there are no queued Task, we can just use the display function
			return display(itemsToDisplay);
		}
		return sb.toString();
	}

	private void displayOtherTasks(int itemsToDisplay, StringBuilder sb, int rCounter, int counter) {
		sb.append("\nOther Tasks:\n");
		int remainingItemsToDisplay = itemsToDisplay - counter;
		counter = 0;
		for (Task oTask : taskList) {
			// Not all other Tasks are displayed, stops when the limit is reached
			if (counter == remainingItemsToDisplay) {
				int remainingOTask = rCounter - remainingItemsToDisplay;
				sb = getRemainingString(sb, remainingOTask, "And %1$s other task\n", "And %1$s other tasks\n");
				break;
			}
			if (oTask.getQueueID() > 0) {
				continue;
			} else {
				sb.append(oTask.display());
				sb.append("\n");
			}
			counter++;
		}
	}

	private int displayQueuedTasks(StringBuilder sb, int qCounter, int queueItemsToDisplay, int counter) {
		sb.append("Queue:\n");
		for (Task qTask : taskList) {
			// Not all queued Tasks are displayed, stops when the limit is reached
			if (counter >= queueItemsToDisplay) {
				int remainingQTask = qCounter - queueItemsToDisplay;
				sb = getRemainingString(sb, remainingQTask, "And %1$s other task in queue\n",
						"And %1$s other tasks in queue\n");
				break;
			}
			if (qTask.getQueueID() != -1) {
				sb.append(qTask.display());
				sb.append("\n");
			} else {
				break;
			}
			counter++;
		}
		return counter;
	}

	private StringBuilder getRemainingString(StringBuilder sb, int remainingTask, String case1, String case2) {
		if (remainingTask == 1) {
			sb.append(String.format(case1, remainingTask));
		} else {
			if (remainingTask > 1) {
				sb.append(String.format(case2, remainingTask));
			}
		}
		return sb;
	}

	public String search(String searchKey) {
		StringBuilder sb = new StringBuilder();
		getExactMatches(searchKey, sb);
		getPartialMatches(searchKey, sb);
		log.log(Level.FINE, "Done searching through taskList for Tasks with searchKey");
		return sb.toString();
	}

	private void getPartialMatches(String searchKey, StringBuilder sb) {
		sb.append("\nPartial Match\n");
		for (Task task : taskList) {
			if (task.containsPartial(searchKey)) {
				sb.append(task.displayAll());
				sb.append("\n");
			}
		}
		log.log(Level.FINE, "Partial matches obtained");
	}

	private void getExactMatches(String searchKey, StringBuilder sb) {
		sb.append("Exact Match\n");
		for (Task task : taskList) {
			if (task.containsExact(searchKey)) {
				sb.append(task.displayAll());
				sb.append("\n");
			}
		}
		log.log(Level.FINE, "Exact matches obtained");
	}

	public void add(ProtoTask task) throws InvalidDateException {
		Task newTask = new Task(task);
		taskList.add(newTask);
		log.log(Level.FINE, "{0} added to tasklist via ProtoTask", newTask.getName());
	}

	public void add(Task task) {
		taskList.add(task);
		log.log(Level.FINE, "{0} added to tasklist via Task", task.getName());
	}

	public void add(int index, Task task) {
		taskList.add(index, task);
		log.log(Level.FINE, "{0} added to tasklist via index:{1} and Task", new Object[] { task.getName(), index });
	}

	public int size() {
		return taskList.size();
	}

	// precondition: there must be a task with taskID in the ArrayList
	public Task delete(int taskID) {
		Task removed = null;
		for (Task task : taskList) {
			if (hasFoundID(taskID, task)) {
				removed = task;
			}
		}
		if (taskList.remove(removed)) {
			log.log(Level.FINE, "{0} has been removed", removed.getName());
		}
		return removed;
	}

	public Task remove(int index) {
		Task t = taskList.remove(index);
		log.log(Level.FINE, "{0} has been removed", t.getName());
		return t;
	}

	// precondition: there must be a task with taskID in the ArrayList
	public void edit(int taskID, ProtoTask toEditTask) throws InvalidDateException {
		for (Task task : taskList) {
			if (hasFoundID(taskID, task)) {
				int taskIndex = taskList.indexOf(task);
				Task newTask = task.edit(toEditTask);
				taskList.set(taskIndex, newTask);
				log.log(Level.FINE, "{0} has been edited", newTask.getName());
			}
		}
	}

	public Task get(int taskID) {
		Task getTask = null;
		for (Task task : taskList) {
			if (hasFoundID(taskID, task)) {
				getTask = task;
			}
		}
		return getTask;
	}

	private boolean hasFoundID(int taskID, Task task) {
		return task.getId() == taskID;
	}

	public Iterator<Task> iterator() {
		return taskList.iterator();
	}

	public void sort(String sortBy, boolean isAscending) {
		if (sortBy != null) {
			if (sortBy.equals("@")) {
				Collections.sort(taskList, new TaskComparators.ComparatorLocation());
				log.log(Level.FINE, "tasklist has been sorted by location");
			}

			if (sortBy.equals("!")) {
				Collections.sort(taskList, new TaskComparators.ComparatorPriority());
				log.log(Level.FINE, "tasklist has been sorted by priority");
			}

			if (sortBy.equals("#")) {
				Collections.sort(taskList, new TaskComparators.ComparatorCategory());
				log.log(Level.FINE, "tasklist has been sorted by category");
			}

			if (sortBy.equals("$")) {
				Collections.sort(taskList, new TaskComparators.ComparatorTime());
				log.log(Level.FINE, "tasklist has been sorted by time");
			}

			if (sortBy.equals("+")) {
				Collections.sort(taskList, new TaskComparators.ComparatorTime());
				log.log(Level.FINE, "tasklist has been sorted by time");
			}

			if (sortBy.equals("&")) {
				Collections.sort(taskList, new TaskComparators.ComparatorAdditional());
				log.log(Level.FINE, "tasklist has been sorted by additional information");
			}

			if (!isAscending) {
				Collections.reverse(taskList);
				log.log(Level.FINE, "tasklist has been sorted in reverse order");
			}
		} else {
			Collections.sort(taskList, new TaskComparators.ComparatorDefault());
			log.log(Level.FINE, "tasklist has been sorted by queue number, then by time");
		}
	}

	public int tasksToday() {
		Calendar c = Calendar.getInstance();
		int count = 0;

		for (Task t : taskList) {

			if (t.isFloating() || t.getStartDate() != null) {
				continue;
			}

			Calendar deadline = t.getEndDate();

			if (c.get(Calendar.YEAR) == deadline.get(Calendar.YEAR)
					&& c.get(Calendar.DAY_OF_YEAR) == deadline.get(Calendar.DAY_OF_YEAR)) {
				count += 1;
			}
		}

		return count;
	}

}
```
###### \src\tucklife\storage\TaskListTest.java
``` java
package tucklife.storage;

import static org.junit.Assert.*;

import java.util.Hashtable;
import java.util.Iterator;

import org.junit.Before;
import org.junit.Test;

import tucklife.parser.Parser;
import tucklife.parser.ProtoTask;
import tucklife.storage.internal.StorageExceptions;
import tucklife.storage.internal.StorageExceptions.InvalidDateException;

public class TaskListTest {

	private Task t;
	private int id;
	private Parser p;
	private ProtoTask pt;
	private TaskList tl;

	@Before
	public void setUp() throws Exception {
		p = new Parser();
		Hashtable<String, String> ht = new Hashtable<String, String>();
		p.loadCommands(ht);
	}

	@Test
	public void testAdd() throws StorageExceptions.InvalidDateException {
		tl = new TaskList();
		pt = p.parse("add meeting");
		tl.add(pt);
		assertEquals("fail to add", 1, tl.size());
		tl.add(pt);
		assertEquals("fail to add", 2, tl.size());
		tl.add(pt);
		tl.add(pt);
		tl.add(pt);
		assertEquals("fail to add", 5, tl.size());
	}

	@Test
	public void testContains() throws InvalidDateException {
		tl = new TaskList();
		pt = p.parse("add meeting");
		t = new Task(pt);
		id = t.getId();
		tl.add(t);
		assertEquals("tl contains, but it doesnt show", true, tl.contains(id));
		assertEquals("contains does not always return true", false, tl.contains(id + 2));
		t = new Task(pt);
		tl.add(t);
		t = new Task(pt);
		tl.add(t);
		assertEquals("tl contains does not work after adding multiple stuff", true, tl.contains(id));
	}

	@Test
	public void testDelete() throws InvalidDateException {
		tl = new TaskList();
		pt = p.parse("add meeting");
		t = new Task(pt);
		id = t.getId();
		Task oldTask = t;
		tl.add(t);
		t = new Task(pt);
		tl.add(t);
		int size = tl.size();
		assertEquals("tasklist does not contain id. should return null.", null, tl.delete(id - 1));
		assertEquals("tasklist size should not change", size, tl.size());
		assertEquals("incorrect task deleted", oldTask, tl.delete(id));
		assertEquals("tasklist size should change", size - 1, tl.size());
	}

	@Test
	public void testEdit() throws InvalidDateException {
		tl = new TaskList();
		pt = p.parse("add meeting @mr4 $16/05 +1300 #intern");
		t = new Task(pt);
		tl.add(t);
		int size = tl.size();
		id = t.getId();
		Task oldTask = t;
		pt = p.parse(String.format("edit %s$1 @mr5 #management #intern", id));
		tl.edit(id, pt);
		assertEquals("tasklist size should not change", size, tl.size());
		pt = p.parse("add hire interns");
		t = new Task(pt);
		tl.add(t);
		assertEquals("the task should not change", oldTask, tl.get(id));
	}

	@Test
	public void testSort() throws InvalidDateException {
		tl = new TaskList();
		pt = p.parse("add meeting @a");
		t = new Task(pt);
		tl.add(t);
		pt = p.parse("add meeting @c");
		t = new Task(pt);
		tl.add(t);
		pt = p.parse("add meeting @f");
		t = new Task(pt);
		tl.add(t);
		pt = p.parse("add meeting @z");
		t = new Task(pt);
		tl.add(t);
		pt = p.parse("add meeting @m");
		t = new Task(pt);
		tl.add(t);
		tl.sort("@", true);
		assertEquals("location should be sorted", true, checkSorted(tl));
	}

	private boolean checkSorted(TaskList unsorted) {
		Iterator<Task> iter = unsorted.iterator();
		Task t = iter.next();
		String prev = t.getLocation();
		while (iter.hasNext()) {
			t = iter.next();
			String curr = t.getLocation();
			if (curr.compareTo(prev) < 0) {
				return false;
			}
			prev = curr;
		}
		return true;
	}

}
```
###### \src\tucklife\storage\TaskTest.java
``` java
package tucklife.storage;

import static org.junit.Assert.*;

import java.util.Hashtable;

import org.junit.Before;
import org.junit.Test;

import tucklife.parser.Parser;
import tucklife.parser.ProtoTask;
import tucklife.storage.internal.StorageExceptions.InvalidDateException;

public class TaskTest {

	private Task t;
	private int id;
	private Parser p;
	private ProtoTask pt;

	@Before
	public void setUp() throws Exception {
		p = new Parser();
		Hashtable<String, String> ht = new Hashtable<String, String>();
		p.loadCommands(ht);
		Task.resetGlobalId();
	}

	@Test
	public void testTask() throws InvalidDateException {
		pt = p.parse("add meeting");
		Task t = new Task(pt);
		assertEquals("fail to create task", "meeting", t.getName());
		assertEquals("unable to get correct location", null, t.getLocation());
		pt = p.parse("add meeting aylward @mr3");
		t = new Task(pt);
		assertEquals("unable to get correct location", "mr3", t.getLocation());
	}

	@Test
	public void testDisplay() throws InvalidDateException {
		pt = p.parse("add meeting");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting        ", id);
		assertEquals("fail to display", taskDisplay, t.display());
		pt = p.parse("add meeting aylward @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		taskDisplay = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 12:00", id);
		assertEquals("fail to display properly", taskDisplay, t.display());
		taskDisplay = String.format(
				"%1$s. meeting aylward | By: Mon, 16 May 2016 12:00 | Location: mr3 | Category: important | Additional: bring all documents",
				id);
		assertEquals("fail to display all properly", taskDisplay, t.displayAll());
	}

	@Test
	public void testEditRemoveParam() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 12:00 | Location: mr3", id);
		pt = p.parse(String.format("edit %1$s @ +1300 $17/05 &", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting aylward | By: Tue, 17 May 2016 13:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
		taskDisplay = String.format("%1$s. meeting aylward | By: Tue, 17 May 2016 13:00 | Category: important", id);
		assertEquals("fail to display all properly", taskDisplay, t.displayAll());
	}

	@Test
	public void testEditRemoveParamFloating() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 12:00 | Location: mr3", id);
		pt = p.parse(String.format("edit %1$s @mr4 &bring yourself +", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting aylward", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
		taskDisplay = String
				.format("%1$s. meeting aylward | Location: mr4 | Category: important | Additional: bring yourself", id);
		assertEquals("fail to display all properly", taskDisplay, t.displayAll());
	}

	@Test
	public void testEditDisplayAll() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		String taskDisplay = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 12:00 | Location: mr3", id);
		pt = p.parse(String.format("edit %1$s @mr4 +1300 &bring yourself", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 13:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
		taskDisplay = String.format(
				"%1$s. meeting aylward | By: Mon, 16 May 2016 13:00 | Location: mr4 | Category: important | Additional: bring yourself",
				id);
		assertEquals("fail to display all properly", taskDisplay, t.displayAll());
	}

	@Test
	public void testEditEventToEventWithoutDate2() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 to 1300 $16/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +1100 to 1200", id));
		t.edit(pt);
		String taskDisplayEdit = String
				.format("%1$s. meeting aylward | From: Mon, 16 May 2016 11:00 To: Mon, 16 May 2016 12:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditEventToEventWithoutDate() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 to 1300 $16/05 to 17/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +0900 to 1000", id));
		t.edit(pt);
		String taskDisplayEdit = String
				.format("%1$s. meeting aylward | From: Mon, 16 May 2016 09:00 To: Tue, 17 May 2016 10:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditEventToDeadline() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 to 1300 $16/05 to 17/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +0900 $16/05", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 09:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditEventToEventWithoutTime() throws InvalidDateException {
		pt = p.parse("add company trip with boss @mr3 +0900 to 1000 $19/05 to 20/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05 to 17/05", id));
		t.edit(pt);
		String taskDisplayEdit = String
				.format("%1$s. company trip... | From: Mon, 16 May 2016 09:00 To: Tue, 17 May 2016 10:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditDeadlineToDeadlineWithoutTime() throws InvalidDateException {
		pt = p.parse("add company trip with boss $17/06 +1500");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip... | By: Mon, 16 May 2016 15:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditFloatToDeadline() throws InvalidDateException {
		pt = p.parse("add company trip with boss");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05 +1500", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip... | By: Mon, 16 May 2016 15:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditFloatToDeadlineWithoutTime() throws InvalidDateException {
		pt = p.parse("add company trip with boss");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. company trip... | By: Mon, 16 May 2016 23:59", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditFloatToEventWithoutTime() throws InvalidDateException {
		pt = p.parse("add company trip with boss");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05 to 17/05", id));
		t.edit(pt);
		String taskDisplayEdit = String
				.format("%1$s. company trip... | From: Mon, 16 May 2016 00:00 To: Tue, 17 May 2016 23:59", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditEventToDeadlineWithoutTime() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 +1200 to 1300 $16/05 to 17/05 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 $16/05", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 23:59", id);
		assertEquals(pt.getStartDate(), null);
		assertEquals(pt.getStartTime(), null);
		assertEquals(pt.getEndTime(), null);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditDeadlineToDeadlineWithoutDate() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 $16/05 +2100 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +0900", id));
		t.edit(pt);
		String taskDisplayEdit = String.format("%1$s. meeting aylward | By: Mon, 16 May 2016 09:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditDeadlineToEventWithoutDate() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 $16/05 +2100 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +0900 to 1700", id));
		t.edit(pt);
		String taskDisplayEdit = String
				.format("%1$s. meeting aylward | From: Mon, 16 May 2016 09:00 To: Mon, 16 May 2016 17:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

	@Test
	public void testEditDeadlineToEventWithoutDate2() throws InvalidDateException {
		pt = p.parse("add meeting aylward @mr3 $16/05 +2100 #important &bring all documents");
		t = new Task(pt);
		id = t.getId();
		pt = p.parse(String.format("edit %1$s @mr4 +2200 to 1000", id));
		t.edit(pt);
		String taskDisplayEdit = String
				.format("%1$s. meeting aylward | From: Mon, 16 May 2016 22:00 To: Tue, 17 May 2016 10:00", id);
		assertEquals("fail to display properly", taskDisplayEdit, t.display());
	}

```
###### \src\tucklife\UI\FlowController.java
``` java
	private enum COMMAND_TYPE {
		ADD, DISPLAY, COMPLETE, DISPLAYDONE, DELETE, EDIT, INVALID, QUEUE, SETLIMIT, UNDO, REDO, UNCOMPLETE
	}

```
###### \src\tucklife\UI\FlowController.java
``` java
	public String parseCommand(ProtoTask pt) {
		COMMAND_TYPE ct = determineCommandType(pt.getCommand());
		String returnMessage = parseCommand(pt,ct);
		return returnMessage;
	}
	
	private static COMMAND_TYPE determineCommandType(String commandTypeString) {
		if (commandTypeString.equalsIgnoreCase("add")) {
			return COMMAND_TYPE.ADD;
		} else if (commandTypeString.equalsIgnoreCase("complete")) {
			return COMMAND_TYPE.COMPLETE;
		} else if (commandTypeString.equalsIgnoreCase("display")) {
			return COMMAND_TYPE.DISPLAY;
		} else if (commandTypeString.equalsIgnoreCase("displaydone")) {
			return COMMAND_TYPE.DISPLAYDONE;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return COMMAND_TYPE.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("edit")) {
			return COMMAND_TYPE.EDIT;
		} else if (commandTypeString.equalsIgnoreCase("queue")) {
			return COMMAND_TYPE.QUEUE;
		} else if (commandTypeString.equalsIgnoreCase("setlimit")) {
			return COMMAND_TYPE.SETLIMIT;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return COMMAND_TYPE.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("uncomplete")) {
			return COMMAND_TYPE.UNCOMPLETE;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return COMMAND_TYPE.REDO;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}
	
	private static String parseCommand(ProtoTask pt, COMMAND_TYPE commandType) throws Error {
		switch (commandType) {
		case ADD :
			try {
				return s.add(pt);
			} catch (OverloadException e) {
				return e.getReturnMsg();
			} catch (InvalidDateException e) {
				return e.getReturnMsg();
			}
		case COMPLETE :
			return s.complete(pt.getId());
		case DISPLAY :
			return s.display(pt, "toDoList");
		case DISPLAYDONE :
			return s.display(pt, "doneList");
		case DELETE :
			return s.delete(pt.getId());
		case EDIT :
			try {
				return s.edit(pt.getId(), pt);
			} catch (OverloadException e) {
				return e.getReturnMsg();
			} catch (InvalidDateException e) {
				return e.getReturnMsg();
			}
		case QUEUE :
			return s.queue(pt.getId(), pt.getPosition());
		case SETLIMIT :
			return s.setLimit(pt.getLimit());
		case UNCOMPLETE :
			return s.uncomplete(pt.getId());
		case UNDO :
			try {
				return s.undo();
			} catch (NothingToUndoException e) {
				return e.getReturnMsg();
			}
		case REDO :
			try {
				return s.redo();
			} catch (NothingToRedoException e) {
				return e.getReturnMsg();
			}
		default:
			throw new Error("Unrecognized command type");
		}
	}
	
	
```
###### \src\tucklife\UI\FlowController.java
``` java
	//for testing purposes only
	public static Storage getStorage(){
		return s;
	}
}
```
