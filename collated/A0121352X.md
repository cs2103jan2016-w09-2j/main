# A0121352X
###### \src\tucklife\storage\DataBox.java
``` java

package tucklife.storage;

import java.util.Hashtable;

import tucklife.storage.external.CommandStorage;
import tucklife.storage.external.PrefsStorage;

public class DataBox {
	
	private TaskList[] lists;
	private PrefsStorage prefs;
	private Hashtable<String, String> commands;
	
	public DataBox(TaskList[] l, PrefsStorage p, CommandStorage c){
		lists = l;
		prefs = p;
		commands = c.getCommands();
	}
	
	public DataBox(TaskList[] l, PrefsStorage p){
		lists = l;
		prefs = p;
	}
	
	public TaskList[] getLists(){
		return lists;
	}
	
	public PrefsStorage getPrefs(){
		return prefs;
	}
	
	public Hashtable<String, String> getCommands() {
		return commands;
	}
	
	public void setCommands(Hashtable<String, String> commands){
		this.commands = commands;
	}
}
```
###### \src\tucklife\storage\external\CommandStorage.java
``` java
package tucklife.storage.external;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Hashtable;

public class CommandStorage {
	
	private static final String FILENAME_COMMANDS = "commands.txt";
	
	private Hashtable<String, String> commandTable;
	
	private String[] commandTypes = { "add", "change", "complete", "delete", "demo", "display", "displaydone",
									  "edit", "exit", "help", "queue", "redo",
									  "save", "saveto", "setlimit", "undo" };
	
	public CommandStorage() {
		commandTable = new Hashtable<String, String>();
	}
	
	public boolean loadCommands() {
		FileInputStream fis;
		InputStreamReader isr;
		BufferedReader br;
		
		try {
			// Create new commands file if it does not exist
			if (!Files.exists(Paths.get(FILENAME_COMMANDS))) {
				Files.createFile(Paths.get(FILENAME_COMMANDS));
			}
			
			// load commands from file
			fis = new FileInputStream(FILENAME_COMMANDS);
			isr = new InputStreamReader(fis);
			br = new BufferedReader(isr);
			
			String[] nextLine;
			
			while(br.ready()){
				nextLine = br.readLine().split(",");
				commandTable.put(nextLine[0], nextLine[1]);
			}
			
			br.close();
			isr.close();
			fis.close();
			
		} catch(IOException ioe){
			ioe.printStackTrace();
			return false;
		}
		
		return true;
	}
	
	public boolean saveCommands(Hashtable<String, String> ht) {
		try {
			FileOutputStream fos = new FileOutputStream(FILENAME_COMMANDS);
			BufferedOutputStream bos = new BufferedOutputStream(fos);
			
			// Write custom commands to file
			for (String key:commandTypes) {
				if (ht.containsKey(key)) {
					String newEntry = key + "," + ht.get(key) + "\n";
					bos.write(newEntry.getBytes());
				}
			}
			
			bos.close();
			fos.close();
		
		// Should not happen under any circumstance
		} catch(FileNotFoundException fnfe){
			return false;
			
		} catch(IOException ioe){
			return false;
		}
		
		return true;
	}
	
	public Hashtable<String, String> getCommands() {
		return commandTable;
	}
}
```
###### \src\tucklife\storage\external\ExternalStorage.java
``` java
package tucklife.storage.external;

import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;
import tucklife.storage.DataBox;
import tucklife.storage.TaskList;

public class ExternalStorage {
	
	private static final Logger EXTERNAL_LOG = Logger.getLogger(ExternalStorage.class.getName());
	
	private static final String FILENAME_TODO = "todo.txt";
	private static final String FILENAME_DONE = "done.txt";
	
	private static final String MSG_SAVE_COMPLETE = "Files saved.";
	
	private static final String ERROR_SAVE = "Error saving files. Files have been saved to TuckLife's folder.";
	private static final String ERROR_SAVETO = "Error saving files to new location. Files have been saved to previous location.";
	
	private static final String LOG_PREFS_COMPLETE = "Preferences loaded successfully.";
	private static final String LOG_PREFS_FAILED = "Using a new default preference file.";
	private static final String LOG_PREFS_SAVEPATH = "Detected savepath: $1%s";
	private static final String LOG_OTHERS_COMPLETE = "Files loaded successfully.";
	private static final String LOG_OTHERS_FAILED = "Error in loading files.";
	private static final String LOG_DATABOX_CREATED = "DataBox created successfully.";
	private static final String LOG_SAVETO_SUCCESS = "Files saved in $1%s successfully.";
	private static final String LOG_DEMO_ACCESS = "Accessing demo for: $1%s";
	
	private String targetFolder;
	private TaskList[] lists;
	private ListStorage todo, done;
	private HelpStorage help;
	private PrefsStorage prefs;
	private CommandStorage commands;
	
	public ExternalStorage(){
		
		// load prefs first
		prefs = new PrefsStorage();		
		boolean prefsLoaded = prefs.loadPreferences();
		
		if(prefsLoaded){
			EXTERNAL_LOG.log(Level.FINE, LOG_PREFS_COMPLETE);
		} else{
			EXTERNAL_LOG.log(Level.WARNING, LOG_PREFS_FAILED);
		}
		
		// create file storage classes
		targetFolder = prefs.getSavePath();
		assert(targetFolder != null);
		EXTERNAL_LOG.log(Level.FINE, String.format(LOG_PREFS_SAVEPATH, targetFolder));
		
		todo = new ListStorage(targetFolder + FILENAME_TODO);
		done = new ListStorage(targetFolder + FILENAME_DONE);		
		help = new HelpStorage();
		commands = new CommandStorage();
	}
	
	// load command - return true on everything okay
	public boolean load(){		
		lists = new TaskList[2];

		lists[0] = todo.getList();
		lists[1] = done.getList();
		
		assert(lists[0] != null);
		assert(lists[1] != null);
		
		boolean loadStatus = todo.getLoadStatus() & done.getLoadStatus() & help.load() & commands.loadCommands();
		
		if(loadStatus){
			EXTERNAL_LOG.log(Level.FINE, LOG_OTHERS_COMPLETE);
		} else{
			EXTERNAL_LOG.log(Level.WARNING, LOG_OTHERS_FAILED);
		}
		
		return loadStatus;
	}
	
	// used to retrieve loaded data in the form of a DataBox
	public DataBox getLoadedData(){
		DataBox db = new DataBox(lists, prefs, commands);
		EXTERNAL_LOG.log(Level.FINE, LOG_DATABOX_CREATED);
		return db;
	}
	
	// normal save command
	public String saveData(DataBox db){
		
		assert(db != null);
		TaskList[] listsToSave = db.getLists();
		prefs = db.getPrefs();
		
		assert(listsToSave[0] != null);
		assert(listsToSave[1] != null);
		assert(prefs != null);
		
		boolean savedTodo = todo.normalSave(listsToSave[0]);
		boolean savedDone = done.normalSave(listsToSave[1]);
		
		boolean savedPrefs = prefs.savePreferences();
		boolean savedCommands = commands.saveCommands(db.getCommands());
		
		if(!savedTodo | !savedDone | !savedPrefs | !savedCommands){
			EXTERNAL_LOG.log(Level.WARNING, ERROR_SAVE);
			return ERROR_SAVE;
		}
		
		EXTERNAL_LOG.log(Level.FINE, MSG_SAVE_COMPLETE);
		return MSG_SAVE_COMPLETE;
	}
	
	// special save command for use during saveto
	public String saveTo(DataBox db, String newPath){
		
		assert(db != null);
		assert(newPath != null);
		
		TaskList[] listsToSave = db.getLists();
		prefs = db.getPrefs();
		
		assert(listsToSave[0] != null);
		assert(listsToSave[1] != null);
		assert(prefs != null);
		
		boolean savedTodo = todo.pathSave(newPath + FILENAME_TODO, listsToSave[0]);
		boolean savedDone = done.pathSave(newPath + FILENAME_DONE, listsToSave[1]);
		
		// saving in new place is successful
		if(savedDone && savedTodo){
			prefs.setSavePath(newPath);
			prefs.savePreferences();
			EXTERNAL_LOG.log(Level.FINE, String.format(LOG_SAVETO_SUCCESS, newPath));
			return MSG_SAVE_COMPLETE;
		
		// saving unsuccessful 
		} else{
			todo.pathSave(targetFolder + FILENAME_TODO, listsToSave[0]);
			done.pathSave(targetFolder + FILENAME_DONE, listsToSave[1]);
			EXTERNAL_LOG.log(Level.WARNING, ERROR_SAVETO);
			return ERROR_SAVETO;
		}
	}
	
	// help and demo retrieval functions
	public String getHelp(){
		return help.getHelp();
	}
	
	public String getDemo(ProtoTask pt){
		String command = pt.getDemoCommand();
		EXTERNAL_LOG.log(Level.FINE, String.format(LOG_DEMO_ACCESS, command));
		return help.getDemo(command);
	}
}
```
###### \src\tucklife\storage\external\ExternalStorageTest.java
``` java
package tucklife.storage.external;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import tucklife.storage.DataBox;
import tucklife.storage.TaskList;

public class ExternalStorageTest {
	
	private ExternalStorage es;

	@Before
	public void setUp() throws Exception {
		es = new ExternalStorage();
	}

	@Test
	public void loadTest() {
		assertEquals(true, es.load());
	}
	
	@Test
	public void DataBoxLoadTest(){
		es.load();
		DataBox db = es.getLoadedData();
		
		TaskList[] lists = db.getLists();
		assertEquals(2, lists.length);
	}
	
	@Test
	public void DataBoxSaveTest(){
		es.load();
		DataBox db = es.getLoadedData();
		
		assertEquals("Files saved.", es.saveData(db));
	}
	
	@Test
	public void DataBoxSavetoSuccessTest(){
		es.load();
		DataBox db = es.getLoadedData();
		
		assertEquals("Files saved.", es.saveTo(db, "test\\"));
	}
	
//	@Test - cannot be run on Mac
//	public void DataBoxSavetoFailTest(){
//		es.load();
//		DataBox db = es.getLoadedData();
//		
//		assertEquals("Error saving files to new location. Files have been saved to previous location.", es.saveTo(db, "nyonexist\\"));
//	}

}
```
###### \src\tucklife\storage\external\HelpStorage.java
``` java
package tucklife.storage.external;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Hashtable;

public class HelpStorage {
	
	public static final String FILENAME_HELP = "help.txt";
	public static final String FILENAME_DEMO = "demo.txt";
	
	public static final String DEMO_LINE1 = "Command: %1$s";
	public static final String DEMO_LINE2 = "Result: %1$s";
	
	private Hashtable<String, ArrayList<String>> demoDirectory;
	private ArrayList<String> helpDirectory;
	
	public HelpStorage(){
		helpDirectory = new ArrayList<String>();
		demoDirectory = new Hashtable<String, ArrayList<String>>();
	}
	
	public boolean load(){
		boolean helpLoaded = loadHelp();
		boolean demoLoaded = loadDemo();
		
		return helpLoaded && demoLoaded;
	}
	
	private boolean loadHelp(){
		
		InputStream is;
		InputStreamReader isr;
		BufferedReader br;
		
		try{
			
			// IDE version
			is = new FileInputStream(FILENAME_HELP);
			
			// JAR version
			//is = this.getClass().getClassLoader().getResourceAsStream(FILENAME_HELP);
			
			isr = new InputStreamReader(is);
			br = new BufferedReader(isr);
			
			// removes first line
			br.readLine();
			
			// read .csv format from file
			while(br.ready()){
				String[] nextLine = br.readLine().split(",");
				helpDirectory.add(nextLine[1] + ":\n");
				helpDirectory.add(nextLine[2]);
			}
			
			br.close();
			isr.close();
			is.close();
			
		} catch(IOException ioe){
			ioe.printStackTrace();
			return false;
		}
		
		return true;
	}
	
	private boolean loadDemo(){
		
		InputStream is;
		InputStreamReader isr;
		BufferedReader br;
		
		try{
			// IDE version
			is = new FileInputStream(FILENAME_DEMO);
			
			// JAR version
			//is = this.getClass().getClassLoader().getResourceAsStream(FILENAME_DEMO);
			
			isr = new InputStreamReader(is);
			br = new BufferedReader(isr);
			
			// removes first line
			br.readLine(); 
			
			String currCommand = null;
			ArrayList<String> exampleTable = new ArrayList<String>();
			
			while(br.ready()){
				String[] nextLine = br.readLine().split(",");
				
				if(currCommand == null){
					currCommand = nextLine[0];
					exampleTable = new ArrayList<String>();
					exampleTable.add(String.format(DEMO_LINE1, nextLine[1]));
					exampleTable.add(String.format(DEMO_LINE2, nextLine[2]));
				
				// same command - add to same entry
				} else if(currCommand.equals(nextLine[0])){
					exampleTable.add(String.format(DEMO_LINE1, nextLine[1]));
					exampleTable.add(String.format(DEMO_LINE2, nextLine[2]));
					
				// different command - start new entry and save current one
				} else{
					demoDirectory.put(currCommand, exampleTable);
					currCommand = nextLine[0];
					exampleTable = new ArrayList<String>();
					exampleTable.add(String.format(DEMO_LINE1, nextLine[1]));
					exampleTable.add(String.format(DEMO_LINE2, nextLine[2]));
				}
			}
			
			demoDirectory.put(currCommand, exampleTable);
			
			br.close();
			isr.close();
			is.close();
			
		} catch(IOException ioe){
			ioe.printStackTrace();
			return false;
		}
		
		return true;
	}
	
	// return entire help directory
	protected String getHelp(){
		
		StringBuilder helpString = new StringBuilder();
		
		for(int i = 0; i < helpDirectory.size(); i += 2){
			helpString.append(helpDirectory.get(i) + helpDirectory.get(i+1));
			helpString.append("\n\n");
		}
		
		return helpString.toString();
	}
	
	// return demo for command input
	protected String getDemo(String command){
		
		StringBuilder demoString = new StringBuilder();
		ArrayList<String> demoTable = demoDirectory.get(command);
		
		for(int i = 0; i < demoTable.size(); i += 2){
			demoString.append(demoTable.get(i));
			demoString.append("\n");
			demoString.append(demoTable.get(i+1));
			demoString.append("\n\n");
		}
		
		demoString.deleteCharAt(demoString.length() - 1);
		
		return demoString.toString();
	}
}
```
###### \src\tucklife\storage\external\HelpStorageTest.java
``` java
package tucklife.storage.external;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

public class HelpStorageTest {
	
	private HelpStorage hs;

	@Before
	public void setUp() throws Exception {
		hs = new HelpStorage();
	}
	
	// test for file access/read
	@Test
	public void loadTest() {
		assertEquals(true, hs.load());
	}
	
	// Partition: functions with only demo command
	@Test
	public void singleDemoTest() {
		hs.load();
		String demo = hs.getDemo("save");
		assertEquals("Command: save\nResult: Saves any changes you have made in TuckLife\n", demo);
	}
	
	// Partition: functions with multiple demo commands
	@Test
	public void multipleDemoTest() {
		hs.load();
		String demo = hs.getDemo("add");
		assertEquals("Command: add board meeting\n"
				+ "Result: Adds the task \"board meeting\" to TuckLife\n"
				+ "\n"
				+ "Command: add board meeting $2 May\n"
				+ "Result: Adds the task \"read a book\" to TuckLife - By: 2 May at 23:59\n"
				+ "\n"
				+ "Command: add board meeting !low #projectX +4pm\n"
				+ "Result: Adds the task \"board meeting\" to TuckLife - By: Today at 16:00 | Priority: low | Category: projectX\n"
				+ "\n"
				+ "Command: add board meeting @meeting room 4 !low #projectX $11 May +4pm to 6pm &bring proposal\n"
				+ "Result: Adds the task \"board meeting\" to TuckLife - From: 11 May 16:00 To: 11 May 18:00 | Location: meeting room 4 | Priority: low | Category: projectX | additional: bring proposal\n"
				, demo);
	}
	
	// test for help file loading - visual inspection due to long file
	@Test
	public void helpTest() {
		hs.load();
		String help = hs.getHelp();
		System.out.println(help);
	}

}
```
###### \src\tucklife\storage\external\ListStorage.java
``` java
package tucklife.storage.external;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import tucklife.parser.ProtoTask;
import tucklife.storage.Task;
import tucklife.storage.TaskList;
import tucklife.storage.internal.StorageExceptions;
import tucklife.storage.internal.StorageExceptions.InvalidDateException;

public class ListStorage {
	
	private static final Logger EXTERNAL_LOG = Logger.getLogger(ExternalStorage.class.getName());
	
	private String targetFile;
	private TaskList list;
	private boolean hasLoadedCorrectly, hasSavedCorrectly;
	
	private static final String HEADER_LOCATION = "Location:";
	private static final String HEADER_CATEGORY = "Category:";
	private static final String HEADER_PRIORITY = "Priority:";
	private static final String HEADER_DEADLINE = "By:";
	private static final String HEADER_ADDITIONAL = "Additional:";
	private static final String HEADER_EVENT_START = "From:";
	private static final String HEADER_QUEUE = "Q:";
	
	private static final String PRIORITY_HIGH = "High";
	private static final String PRIORITY_MEDIUM = "Med";
	private static final String PRIORITY_LOW = "Low";
	
	private static final String LOG_TASK_DATE_ERROR = "Error loading task dates";	
	private static final String LOG_TASK_NAME = "Loaded task name: $1%s";
	private static final String LOG_TASK_LOCATION = "Loaded task location: $1%s";
	private static final String LOG_TASK_CATEGORY = "Loaded task category: $1%s";
	private static final String LOG_TASK_PRIORITY = "Loaded task priority: $1%s";
	private static final String LOG_TASK_ADDITIONAL = "Loaded task additional: $1%s";
	private static final String LOG_TASK_QUEUE = "Loaded task queueNo: $1%s";
	private static final String LOG_TASK_END = "Loaded task end: $1%s";
	private static final String LOG_TASK_START = "Loaded task start: $1%s";
	private static final String LOG_SAVE_TASK = "Saved task: $1%s";
	private static final String LOG_SAVE_QUEUE = "Task queueNo: $1%s";
	
	protected ListStorage(String fileName){
		targetFile = fileName;
		list = new TaskList();
		hasLoadedCorrectly = false;
		hasSavedCorrectly = false;
	}
	
	// loads the required TaskList (todo or done list) - returns true if loaded ok - false if not
	private boolean loadList(){
		
		FileInputStream fis;
		InputStreamReader isr;
		BufferedReader br;
		
		assert(targetFile != null);
		
		try{
			fis = new FileInputStream(targetFile);
			isr = new InputStreamReader(fis);
			br = new BufferedReader(isr);
			
			while(br.ready()){
				String nextTask = br.readLine();
				
				if(!nextTask.equals("")){
					ProtoTask pt = parseTask(nextTask);
					
					try {
						list.add(pt);
					} catch (InvalidDateException e) {
						// should not happen if save was correct
						EXTERNAL_LOG.log(Level.WARNING, LOG_TASK_DATE_ERROR);		
					}
				}			
			}
			
			br.close();
			isr.close();
			fis.close();
			
			hasLoadedCorrectly = true;
		
		// either file not created yet or TuckLife/the files were moved
		// ignore as new files will be created on save
		} catch(FileNotFoundException fnfe){
			hasLoadedCorrectly = true;
		} catch(IOException ioe){
			hasLoadedCorrectly = false;
		}
		
		return hasLoadedCorrectly;
	}
	
	// converts string version of task into ProtoTask form
	private ProtoTask parseTask(String task){
		ProtoTask pt = new ProtoTask("add");
		
		String[] taskDetails = task.split("\\|");
		
		pt.setTaskDesc(taskDetails[0].trim());
		
		EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_NAME, taskDetails[0].trim()));
		
		for(int i = 1; i < taskDetails.length; i++){
			processField(pt, taskDetails[i].trim());
		}
		
		return pt;
	}
	
	// process each part of a task String to extract a parameter
	private ProtoTask processField(ProtoTask pt, String field){
		String[] fieldDetails = field.split(" ");
		String fieldHeader = fieldDetails[0];
		
		if(fieldHeader.equalsIgnoreCase(HEADER_CATEGORY)){
			pt.setCategory(removeFirstWord(field));
			EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_CATEGORY, removeFirstWord(field)));
			
		} else if(fieldHeader.equalsIgnoreCase(HEADER_PRIORITY)){
			String p = fieldDetails[1];
			if(p.equalsIgnoreCase(PRIORITY_HIGH)){
				pt.setPriority(1);
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_PRIORITY, PRIORITY_HIGH));
			} else if(p.equalsIgnoreCase(PRIORITY_MEDIUM)){
				pt.setPriority(2);
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_PRIORITY, PRIORITY_MEDIUM));
			} else if(p.equalsIgnoreCase(PRIORITY_LOW)){
				pt.setPriority(3);
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_PRIORITY, PRIORITY_LOW));
			}
			
		} else if(fieldHeader.equalsIgnoreCase(HEADER_LOCATION)){
			pt.setLocation(removeFirstWord(field));
			EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_LOCATION, removeFirstWord(field)));
			
		} else if(fieldHeader.equalsIgnoreCase(HEADER_ADDITIONAL)){
			pt.setAdditional(removeFirstWord(field));
			EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_ADDITIONAL, removeFirstWord(field)));
			
		} else if(fieldHeader.equalsIgnoreCase(HEADER_DEADLINE)){
			processTime(false, pt, field);
		} else if(fieldHeader.equalsIgnoreCase(HEADER_EVENT_START)){
			processTime(true, pt, field);
		} else if(fieldHeader.equalsIgnoreCase(HEADER_QUEUE)){
			pt.setPosition(Integer.parseInt(removeFirstWord(field)));
			EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_QUEUE, Integer.parseInt(removeFirstWord(field))));
		}		
		return pt;
	}
	
	// for the annoying process of determining the time from the string
	private ProtoTask processTime(boolean event, ProtoTask pt, String field){
		
		if(event){
			String[] fieldDetails = field.split(" ");
			StringBuilder startDate = new StringBuilder();
			StringBuilder endDate = new StringBuilder();
			
			for(int j = 1; j <= 5; j++){
				startDate.append(fieldDetails[j] + " ");
			}
			
			for(int j = 7; j <= 11; j++){
				endDate.append(fieldDetails[j] + " ");
			}
			
			String sDate = startDate.toString();
			String eDate = endDate.toString();
			
			try{
				SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
				Calendar cStart = Calendar.getInstance();
				Calendar cEnd = Calendar.getInstance();
				cStart.setTime(sdf.parse(sDate));
				cEnd.setTime(sdf.parse(eDate));
				
				pt.setStartDate(cStart);
				pt.setEndDate(cEnd);
				
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_START, cStart.getTime().toString()));
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_END, cEnd.getTime().toString()));
			
			// dates is wrong - ignore them	
			} catch(ParseException pe){
				// do nothing - wrong date is the same as no date
			}
			
		} else{
			try{
				SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
				Calendar c = Calendar.getInstance();
				c.setTime(sdf.parse(removeFirstWord(field)));
				
				pt.setEndDate(c);
				
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_TASK_END, c.getTime().toString()));
			
			// date is wrong - ignore it	
			} catch(ParseException pe){
				// do nothing - wrong date is the same as no date
			}
		}
		
		return pt;
	}
	
	private String removeFirstWord(String s){
		for(int i = 0; i < s.length(); i++){
			if(s.charAt(i) == ' '){
				return s.substring(i+1);
			}
		}	
		return s;
	}
	
	// for use by main ExternalStorage
	protected TaskList getList(){
		
		hasLoadedCorrectly = false;
		loadList();
		
		if(hasLoadedCorrectly){
			return list;
		} else{
			return new TaskList();
		}
	}
	
	// status of load
	protected boolean getLoadStatus(){
		return hasLoadedCorrectly;
	}
	
	// exact opposite - saves the todo list and returns true on success
	private boolean saveList(String fileName){
		
		FileOutputStream fos;
		BufferedOutputStream bos;
		
		try{
			fos = new FileOutputStream(fileName);
			bos = new BufferedOutputStream(fos);
			
			Iterator<Task> tasks = list.iterator();
			
			while(tasks.hasNext()){
				Task t = tasks.next();
				
				String taskString = t.displayAll().trim();
				
				// remove the id as we do not save it
				int idBreak = taskString.indexOf((int) ' ');				
				taskString = taskString.substring(idBreak + 1);
				
				bos.write(taskString.getBytes());
				
				EXTERNAL_LOG.log(Level.FINER, String.format(LOG_SAVE_TASK, taskString));
				
				// add queueId if there is one
				if(t.getQueueID() != -1){
					bos.write((" | " + HEADER_QUEUE + " " + Integer.toString(t.getQueueID())).getBytes());
					EXTERNAL_LOG.log(Level.FINER, String.format(LOG_SAVE_QUEUE, Integer.toString(t.getQueueID())));
				}
				bos.write("\n".getBytes());
			}
			
			bos.flush();
			bos.close();
			fos.close();
			
			hasSavedCorrectly = true;
			
		} catch(IOException ioe){
			hasSavedCorrectly = false;
		}
		
		return hasSavedCorrectly;
	}
	
	// normal saving - for use by ExternalStorage
	protected boolean normalSave(TaskList listToSave){
		hasSavedCorrectly = false;
		list = listToSave;
		return saveList(targetFile);
	}
	
	// used when save path is changed
	protected boolean pathSave(String newTargetFile, TaskList listToSave){
		hasSavedCorrectly = false;
		list = listToSave;
		saveList(newTargetFile);
		
		if(hasSavedCorrectly){
			targetFile = newTargetFile;
		}
		
		return hasSavedCorrectly;
	}
}
```
###### \src\tucklife\storage\external\ListStorageTest.java
``` java
package tucklife.storage.external;

import static org.junit.Assert.*;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;

import org.junit.Before;
import org.junit.Test;

import tucklife.storage.Task;
import tucklife.storage.TaskList;


public class ListStorageTest {
	
	private ListStorage todo, done;
	private TaskList todoList, doneList;
	
	private static final String TEST_PATH = "test\\";
	private static final String TEST_PATH_RELATIVE = "test\\relative\\";
	private static final String FILENAME_TODO = "todo.txt";
	private static final String FILENAME_DONE = "done.txt";
	private static final String FILENAME_TODO_TEST = "todoTest.txt";
	private static final String FILENAME_DONE_TEST = "doneTest.txt";
	private static final String FILENAME_TODO_RES = "todoRes.txt";
	private static final String FILENAME_DONE_RES = "doneRes.txt";
	
	@Before
	public void setUp() throws Exception {
		
		// make copies of the base test files
		FileInputStream fisTodo, fisDone;
		InputStreamReader isrTodo, isrDone;
		BufferedReader brTodo, brDone;
		
		FileOutputStream fosTodo, fosDone;
		BufferedOutputStream bosTodo, bosDone;
		
		Task.resetGlobalId();
		
		try{
			fisTodo = new FileInputStream(TEST_PATH + FILENAME_TODO_TEST);
			isrTodo = new InputStreamReader(fisTodo);
			brTodo = new BufferedReader(isrTodo);
			
			fosTodo = new FileOutputStream(TEST_PATH + FILENAME_TODO);
			bosTodo = new BufferedOutputStream(fosTodo);
			
			while(brTodo.ready()){
				String nextTask = brTodo.readLine();
				
				if(!nextTask.equals("")){
					bosTodo.write(nextTask.getBytes());
					bosTodo.write("\n".getBytes());
				}			
			}
			
			brTodo.close();
			isrTodo.close();
			fisTodo.close();
			
			bosTodo.close();
			fosTodo.close();
			
			fisDone = new FileInputStream(TEST_PATH + FILENAME_DONE_TEST);
			isrDone = new InputStreamReader(fisDone);
			brDone = new BufferedReader(isrDone);
			
			fosDone = new FileOutputStream(TEST_PATH + FILENAME_DONE);
			bosDone = new BufferedOutputStream(fosDone);
			
			while(brDone.ready()){
				String nextTask = brDone.readLine();
				
				if(!nextTask.equals("")){
					bosDone.write(nextTask.getBytes());
					bosDone.write("\n".getBytes());
				}			
			}
			
			brDone.close();
			isrDone.close();
			fisDone.close();
			
			bosDone.close();
			fosDone.close();
		
		// should not happen if test files are there - this will cause tests to fail
		} catch(IOException ioe){
			assert(true == false);
		}
	
		todo = new ListStorage(TEST_PATH + FILENAME_TODO);
		done = new ListStorage(TEST_PATH + FILENAME_DONE);
		todoList = todo.getList();
		doneList = done.getList();
	}
	
	// checks if basic load function executed correctly
	@Test
	public void loadTest() {		
		assertEquals(true, todo.getLoadStatus());
		assertEquals(true, done.getLoadStatus());
	}
	
	// checks that each individual task type is handled correctly
	@Test
	public void taskTest(){
		
		// todo list should have eight tasks as test file has seven tasks
		// task5, 4, 11, 8, 6, 7, 3, 12
		
		assertEquals(true, todoList.contains(1));
		assertEquals(true, todoList.contains(2));
		assertEquals(true, todoList.contains(3));
		assertEquals(true, todoList.contains(4));
		assertEquals(true, todoList.contains(5));
		assertEquals(true, todoList.contains(6));
		assertEquals(true, todoList.contains(7));
		assertEquals(true, todoList.contains(8));
			
		// done list should have four tasks - task1, task9, task2, task10
		assertEquals(true, doneList.contains(9));
		assertEquals(true, doneList.contains(10));
		assertEquals(true, doneList.contains(11));
		assertEquals(true, doneList.contains(12));
		
		// first task type - no parameters
		String task = doneList.displayID(9);
		assertEquals(" 9. task1", task);
		
		// second task type - location parameter
		task = doneList.displayID(11);
		assertEquals("11. task2 | Location: loc2", task);
		
		// third task type - priority parameter
		task = todoList.displayID(7);
		assertEquals(" 7. task3 | Priority: High", task);
		
		// fourth task type - deadline parameter (day only)
		task = todoList.displayID(2);
		assertEquals(" 2. task4 | By: Mon, 04 Apr 2016 23:59", task);
		
		// fifth task type - deadline parameter (time only)
		task = todoList.displayID(1);
		assertEquals(" 1. task5 | By: Tue, 29 Mar 2016 05:00", task);
			
		// sixth task type - category parameter
		task = todoList.displayID(5);
		assertEquals(" 5. task6 | Category: cat6", task);
		
		// seventh task type - additional parameter
		task = todoList.displayID(6);
		assertEquals(" 6. task7 | Additional: additional7", task);
		
		// eighth task type - event (days only)
		task = todoList.displayID(4);
		assertEquals(" 4. task8 | From: Mon, 08 Aug 2016 23:59 To: Wed, 10 Aug 2016 23:59", task);
		
		// ninth task type - event (time only)
		task = doneList.displayID(10);
		assertEquals("10. task9 | From: Tue, 29 Mar 2016 09:00 To: Tue, 29 Mar 2016 10:00", task);
		
		// tenth task type - event (both date and time)
		task = doneList.displayID(12);
		assertEquals("12. task10 | From: Wed, 10 Aug 2016 22:00 To: Fri, 12 Aug 2016 23:00", task);
		
		// eleventh task type - queue ID
		task = todoList.displayID(8);
		assertEquals(" 8. task12", task);
		Task t = todoList.delete(8);
		assertEquals(1, t.getQueueID());
		
		// consolidation - all parameters
		task = todoList.displayID(3);
		assertEquals(" 3. task11 | By: Mon, 11 Apr 2016 23:59 | Location: loc11 | Priority: Med | Category: cat11 | Additional: additional11", task);
	}
	
	// check that you can save without any changes
	@Test
	public void saveUnchangedTest(){
		assertEquals(true, done.normalSave(doneList));
		assertEquals(true, todo.normalSave(todoList));
	}
	
	// check that you can save changes - files are named differently for the sake of comparison
	@Test
	public void saveChangedTest(){		
		// simulate a complete
		Task t = todoList.delete(4);
		doneList.add(t);
		
		// simulate a delete
		t = todoList.delete(3);
		
		// save and compare doneRes and todoRes with doneExpected and todoExpected	
		assertEquals(true, done.pathSave(TEST_PATH + FILENAME_DONE_RES, doneList));
		assertEquals(true, todo.pathSave(TEST_PATH + FILENAME_TODO_RES, todoList));
	}
	
	
	// checks that a relative saveto path works.
	@Test
	public void savetoRelativeTest(){			
		assertEquals(true, done.pathSave(TEST_PATH_RELATIVE + FILENAME_DONE, doneList));
		assertEquals(true, todo.pathSave(TEST_PATH_RELATIVE + FILENAME_TODO, todoList));
	}
	
	// unfortunately global saveto cannot be tested automatically 
	// without prior knowledge of computer running test
	
}
```
###### \src\tucklife\storage\external\PrefsStorage.java
``` java
package tucklife.storage.external;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class PrefsStorage {
	
	private static final String FILENAME_PREFS = "prefs.txt";
	private static final String FILE_BLANK = "Preferences:\n\n50";
	private static final String FILE_HEADER = "Preferences:";
	
	private String testPath;
	private String savePath;
	private int overloadLimit;
	
	// unused variables
//	private boolean reminderOn;
//	
//	private String defLocation;
//	private int defPriority;
//	private String defCategory;
//	private String defAdditional;
	
	public PrefsStorage(){
		// default values
		savePath = "";
		overloadLimit = 50;
		testPath = "";
		
		// unused
//		reminderOn = true;
//		
//		defLocation = "";
//		defPriority = -1;
//		defCategory = "";
//		defTime = "";
//		defAdditional = "";
//		
//		testPath = "";
	}
	
	// special constructor meant for testing only
	protected PrefsStorage(String path){
		// default values
		savePath = "";
		overloadLimit = 50;
		testPath = path;
		
		// unused
//		reminderOn = true;		
//		defLocation = "";
//		defPriority = -1;
//		defCategory = "";
//		defTime = "";
//		defAdditional = "";
	}
	
	protected boolean loadPreferences(){
			
		// check for existence of prefs file.
		try{
			boolean loaded = loadPrefs();
			return loaded;
		
		// file not found - create a blank one now
		} catch(FileNotFoundException fnfe){
			boolean loaded = writeBlankPrefs();	
			return loaded;
		}
	}
	
	private boolean loadPrefs() throws FileNotFoundException{
		try{
			FileInputStream fis = new FileInputStream(testPath + FILENAME_PREFS);
			InputStreamReader isr = new InputStreamReader(fis);
			BufferedReader br = new BufferedReader(isr);
			
			/* 
			 * format for prefs file
			 * line 0 - Preferences:
			 * line 1 - savePath
			 * line 2 - overload limit
			 */
			
			// remove first line
			br.readLine();
			
			savePath = br.readLine();
			overloadLimit = Integer.parseInt(br.readLine());
			
//			defLocation = br.readLine();
//			defPriority = Integer.parseInt(br.readLine());
//			defCategory = br.readLine();
//			defTime = br.readLine();
//			defAdditional = br.readLine();
//					
//			reminderOn = Boolean.parseBoolean(br.readLine());
			
			br.close();
			isr.close();
			fis.close();
			
			return true;
		
		// signal that a new blank prefs.txt is needed
		} catch(FileNotFoundException fnfe){
			throw fnfe;
			
		} catch(IOException ioe){
			return false;
		}
	}
	
	private boolean writeBlankPrefs(){
		try{
			FileOutputStream fos = new FileOutputStream(testPath + FILENAME_PREFS);
			BufferedOutputStream bos = new BufferedOutputStream(fos);
			
			// write blank preferences
			bos.write(FILE_BLANK.getBytes());
			
			bos.close();
			fos.close();
		
		// should not happen under normal use
		} catch(FileNotFoundException fnfe){
			return false;
			
		} catch(IOException ioe){
			return false;
		}
		
		return true;
	}
	
	protected boolean savePreferences(){
		try{
			FileOutputStream fos = new FileOutputStream(testPath + FILENAME_PREFS);
			BufferedOutputStream bos = new BufferedOutputStream(fos);
			
			/* 
			 * format for prefs file
			 * line 0 - Preferences:
			 * line 1 - savePath
			 * line 2 - overload limit
			 */
			
			// write preferences to file
			bos.write(FILE_HEADER.getBytes());
			bos.write("\n".getBytes());
			
			bos.write(savePath.getBytes());
			bos.write("\n".getBytes());
			
			bos.write(Integer.toString(overloadLimit).getBytes());
			bos.write("\n".getBytes());
			
//			bos.write(defLocation.getBytes());
//			bos.write("\n".getBytes());
//			
//			bos.write(Integer.toString(defPriority).getBytes());
//			bos.write("\n".getBytes());
//			
//			bos.write(defCategory.getBytes());
//			bos.write("\n".getBytes());
//			
//			bos.write(defTime.getBytes());
//			bos.write("\n".getBytes());
//			
//			bos.write(defAdditional.getBytes());
//			bos.write("\n".getBytes());
//			
//			bos.write(Boolean.toString(reminderOn).getBytes());
//			bos.write("\n".getBytes());
//			
			bos.close();
			fos.close();
		
		// should not happen unless file was deleted after startup
		} catch(FileNotFoundException fnfe){
			return false;
			
		} catch(IOException ioe){
			return false;
		}
		
		return true;
	}
	
	protected void setSavePath(String savePath) {
		this.savePath = savePath;
	}

	public void setOverloadLimit(int overloadLimit) {
		this.overloadLimit = overloadLimit;
	}
	
	protected String getSavePath(){
		return savePath;
	}
	
	public int getOverloadLimit(){
		return overloadLimit;
	}
	
```
###### \src\tucklife\storage\external\PrefsStorageTest.java
``` java
package tucklife.storage.external;

import static org.junit.Assert.*;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;

import org.junit.Before;
import org.junit.Test;


public class PrefsStorageTest {
	
	private PrefsStorage psNormal, psTester;
	
	private static final String TEST_PATH = "test\\";
	private static final String TEST_NEWPATH_RELATIVE = "test\\relative\\";
	private static final String TEST_NEWPATH_GLOBAL = "C:\\Users\\Ryan\\Desktop\\Holding Area\\";
	private static final String FILENAME_PREFS_TEST = "prefsTest.txt";
	private static final String FILENAME_PREFS = "prefs.txt";

	@Before
	public void setUp() throws Exception {
		psNormal = new PrefsStorage();
		psTester = new PrefsStorage(TEST_PATH);
	}
	
	// delete test\prefs.txt before starting
	// test for file creation/loading
	@Test
	public void createAndLoadTest(){
		// loading normal prefs.txt
		assertEquals(true, psNormal.loadPreferences());
		// creating a special test\prefs.txt
		assertEquals(true, psTester.loadPreferences());
	}
	
	// check that the used default values are okay 
	@Test
	public void defaultValuesTest() {
		assertEquals("", psTester.getSavePath());
		assertEquals(50, psTester.getOverloadLimit());
	}
	
	// save without changing anything
	@Test
	public void unchangedTest(){
		psTester.loadPreferences();		
		assertEquals(true, psTester.savePreferences());	
	}
	
	// modify the parameters that we use and see that they are saved correctly
	@Test
	public void saveTest(){
		psTester.loadPreferences();
		
		psTester.setOverloadLimit(31);
		psTester.setSavePath(TEST_NEWPATH_RELATIVE);
		
		assertEquals(true, psTester.savePreferences());
	}
	
	// check if loading an existing file works
	@Test
	public void loadValueTest(){
		// copy the base test file into test\prefs.txt 
		FileInputStream fis;
		InputStreamReader isr;
		BufferedReader br;
				
		FileOutputStream fos;
		BufferedOutputStream bos;
				
		try{
			fis = new FileInputStream(TEST_PATH + FILENAME_PREFS_TEST);
			isr = new InputStreamReader(fis);
			br = new BufferedReader(isr);
					
			fos = new FileOutputStream(TEST_PATH + FILENAME_PREFS);
			bos = new BufferedOutputStream(fos);
					
			while(br.ready()){
				String nextLine = br.readLine();
				bos.write(nextLine.getBytes());
				bos.write("\n".getBytes());			
			}
					
			br.close();
			isr.close();
			fis.close();
					
			bos.close();
			fos.close();
		
		// should not happen if test file is present
		} catch(IOException ioe){
			
		}

		psTester.loadPreferences();
		
		assertEquals(TEST_NEWPATH_GLOBAL, psTester.getSavePath());
		assertEquals(74, psTester.getOverloadLimit());
	}

}
```
###### \src\tucklife\storage\internal\Storage.java
``` java
	private static final String STATUS_HEADER = "\n\n\n\n\n\n\n\n\n\nTasks at a glance...";
	private static final String STATUS_OUTSTANDING = "Total outstanding tasks: %1$s";
	private static final String STATUS_TODAY = "Tasks due today: %1$s";
	private static final String STATUS_CURRENT = "Current task: {%1$s}";
	private static final String STATUS_CURRENT_NONE = "None";

```
###### \src\tucklife\storage\internal\Storage.java
``` java
	public String getStatus() {
		StringBuilder status = new StringBuilder();

		status.append(STATUS_HEADER);
		status.append("\n");
		status.append(String.format(STATUS_OUTSTANDING, Integer.toString(toDoList.size())));
		status.append("\n");
		status.append(String.format(STATUS_TODAY, Integer.toString(toDoList.tasksToday())));
		status.append("\n");
		if (queueList.size() != 0) {
			status.append(String.format(STATUS_CURRENT, queueList.display(10).split("\n")[0]));
		} else {
			status.append(String.format(STATUS_CURRENT, STATUS_CURRENT_NONE));
		}

		return status.toString();
	}

```
###### \src\tucklife\UI\FlowController.java
``` java
	public String executeSave() {
		DataBox db = s.save();
		db.setCommands(p.getCommands());
		return es.saveData(db);
	}
	
	public String executeSaveTo(String path) {
		DataBox db = s.save();
		db.setCommands(p.getCommands());
		return es.saveTo(db, path);
	}
	
```
